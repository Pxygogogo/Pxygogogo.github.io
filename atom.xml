<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pxygogogo.github.io</id>
    <title>小潘的博客</title>
    <updated>2020-03-14T05:17:54.583Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pxygogogo.github.io"/>
    <link rel="self" href="https://pxygogogo.github.io/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://pxygogogo.github.io/images/avatar.png</logo>
    <icon>https://pxygogogo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[浏览器中堆栈内存的底层处理]]></title>
        <id>https://pxygogogo.github.io/post/stack-heap-in-browser/</id>
        <link href="https://pxygogogo.github.io/post/stack-heap-in-browser/">
        </link>
        <updated>2020-03-13T05:31:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器执行代码需要经历什么">浏览器执行代码需要经历什么</h2>
<h3 id="编译">编译</h3>
<ul>
<li>词法解析：这个过程会将由字符组成的字符串分解成有意义的代码块（词法单元）</li>
<li>语法分析：这个过程将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法的树（抽象语法树 =&gt; <mark>AST</mark>）</li>
<li>代码生成：将<mark>AST</mark>转换为可执行代码的过程被称为代码生成</li>
</ul>
<h3 id="引擎编译执行代码">引擎编译执行代码</h3>
<p>然后将构建出的代码交给引擎（V8），这个时候可能会遇到<mark>变量提升、作用域和作用域链/闭包、变量对象、堆栈内存、GO/VO/AO/EC/ECStack</mark>...</p>
<blockquote>
<h4 id="几个术语说明">几个术语说明：</h4>
<p><mark>ECstack</mark>：执行上下文环境栈</p>
<p><mark>EC</mark>：执行上下文 分为全局执行上下文 <mark>EC(G)</mark> 和函数执行上下文(<mark>EC(...)</mark>)</p>
<p><mark>GO(Global Object)</mark>：全局对象浏览器端，会把GO赋值给window</p>
<p><mark>VO(Varible Object)</mark>：变量对象，存储当前上下文中的变量</p>
<p><mark>AO(Activation Object)</mark>：活动对象，在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色</p>
</blockquote>
<p>引擎在编译执行代码的过程中，首先会创建一个执行栈，也就是栈内存（ECStack =&gt; 执行环境栈），然后执行代码</p>
<p>在代码执行会创建EC(执行上下文)，执行上下文分为全局执行上下文（EC(G)）和函数执行上下文（EC(...)）,其中函数的执行上下文是私有的。</p>
<p>创建执行上下文的过程中，可能会创建：GO、VO、AO<br>
然后将进栈执行，创建好的上下文将压缩到栈中执行，执行后一些没用的上下文将出栈，有用的上下文会压缩到栈底（闭包）。栈底永远是全局执行上下文，栈顶则永远是当前执行上下文</p>
<h3 id="变量赋值的三步操作">变量赋值的三步操作</h3>
<ul>
<li>
<p>第一步，创建变量，这个过程叫做声明(declare)。</p>
</li>
<li>
<p>第二步，创建值。基本类型值会直接在栈中创建和存储；由于引用类型值是复杂的结构，所以需开辟一个存储对象中键值对（存储函数中代码）的内存空间，这个内存就是堆内存，所有的堆内存都有可被后续查找的16进制地址，后续关联赋值时，是把堆内存地址给予变量操作。</p>
</li>
<li>
<p>最后一步，将变量和值关联，这个过程叫做定义(defined)。这里，如果值只经过了声明，而没有进行赋值操作，这个值就是未定义(undefined)。</p>
</li>
</ul>
<blockquote>
<p>注：简单理解为</p>
<ul>
<li>栈内存存放执行代码和基本类型的值</li>
<li>堆内存存放复杂结构，如对象</li>
</ul>
</blockquote>
<p>例题：</p>
<pre><code>// 例一
let a = 12;
let b = a;
b = 13;
console.log(a);

// 例二
let a = {n:12};
let b = a;
b['n'] = 13;
console.log(a.n);

// 例三
let a = {n:12};
let b = a;
b = {n:13};
console.log(a.n);

</code></pre>
<p>例一<br>
<img src="https://s1.ax1x.com/2020/03/13/8nyz8A.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a值为12</p>
<p>例二<br>
<img src="https://s1.ax1x.com/2020/03/13/8n6AUg.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a.n为13</p>
<p>例三<br>
<img src="https://s1.ax1x.com/2020/03/13/8ncQSA.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a.n的值为12</p>
<h3 id="真实面试题">真实面试题</h3>
<ul>
<li>题一</li>
</ul>
<pre><code>let a = {
    n: 10
};
let b = a;
b.m = b = {
    n: 20
};
console.log(a);
console.log(b);

</code></pre>
<ul>
<li>解一<br>
<img src="https://s1.ax1x.com/2020/03/13/8n2zo8.jpg" alt="image" loading="lazy"></li>
</ul>
<p>所以最终输出的a为{n: 10, m: {n: 20}};b为{n: 20}</p>
<ul>
<li>题二</li>
</ul>
<pre><code>let x = [12, 23];
function fn(y) {
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y);
}
fn(x);
console.log(x);

</code></pre>
<ul>
<li>解二<br>
<img src="https://s1.ax1x.com/2020/03/13/8nvnzR.jpg" alt="image" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/03/13/8nv3dO.jpg" alt="image" loading="lazy"></figure>
<p>答案是：[100, 200] [100, 23]</p>
<h3 id="思考题">思考题</h3>
<ul>
<li>思考题一</li>
</ul>
<pre><code>var x = 10;
~ function (x) {
    console.log(x);
    x = x || 20 &amp;&amp; 30 || 40;
    console.log(x);
}();
console.log(x);
</code></pre>
<ul>
<li>思考题二</li>
</ul>
<pre><code>let x = [1, 2],
    y = [3, 4];
~ function (x) {
    x.push('A');
    x = x.slice(0);
    x.push('B');
    x = y;
    x.push('C');
    console.log(x, y);
}(x);
console.log(x, y);
</code></pre>
<ul>
<li>思考题一答案</li>
</ul>
<p><mark>undefined 30 10</mark></p>
<ul>
<li>思考题二答案</li>
</ul>
<p><mark>[3, 4, 'C'] [3, 4, 'C'] [1, 2, 'A'] [3, 4, 'C']</mark></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mongoose得到的对象不能增加属性解决方法（两种）]]></title>
        <id>https://pxygogogo.github.io/post/mongoose-query/</id>
        <link href="https://pxygogogo.github.io/post/mongoose-query/">
        </link>
        <updated>2020-03-11T04:39:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实例">实例</h2>
<ul>
<li>Notice模型文件如下：</li>
</ul>
<pre><code>const mongoose = require('mongoose');

const schema = mongoose.Schema({
    userId:{type:String},
    time: {type:String},
    medicines: {type:Array},
    noticePerson:{type:String},
    acrtTime:{type:String},
});

module.exports = mongoose.model('Notice',schema);
</code></pre>
<ul>
<li>路由响应如下：</li>
</ul>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            result.email = email; //无法生效
            res.send(result);
        }
    });
</code></pre>
<ul>
<li>问题描述：<br>
希望向得到的result数据中添加一个email属性，但直接添加无法成功</li>
</ul>
<hr>
<h2 id="原因">原因</h2>
<ul>
<li>因为Mongoose是個ODM (Object Document Mapper)，类似于操作关系型数据库使用的ORM(Object Relational Mapper)，我们使用Mongoose取到的数据的结构是要依赖于我们定义的schema结构的。增加的email属性在schema中没有定义，所以我们在取到的结果中增加email属性是无效的</li>
</ul>
<hr>
<h2 id="解决办法">解决办法</h2>
<ul>
<li>解决办法一</li>
</ul>
<p><mark>在schema中直接增加需要补充的属性</mark></p>
<p>在本例中即向Notice模型中添加一个email字段</p>
<ul>
<li>解决办法二</li>
</ul>
<p><mark>把查询到的结果clone一个对象，然后在新对象中补充属性</mark></p>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            const data = {
                ...result._doc,
                email,
            };
            res.send(data);
        }
    });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssh 免密码快速登录（MacOs）]]></title>
        <id>https://pxygogogo.github.io/post/ssh-login/</id>
        <link href="https://pxygogogo.github.io/post/ssh-login/">
        </link>
        <updated>2020-03-05T11:47:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建秘钥文件">1.创建秘钥文件</h2>
<ul>
<li>打开终端，执行 ssh-keygen 命令创建密钥对：</li>
</ul>
<blockquote>
<pre><code class="language-bash">ssh-keygen -t rsa -C 'your email@domain.com'
-t 指定密钥类型，默认即 rsa ，可以省略
-C 设置注释文字，比如你的邮箱，可以省略
</code></pre>
</blockquote>
<ul>
<li>生成过程中会提示输入密码两次，如果不想在使用公钥的时候输入密码，可以回车跳过；<br>
密钥默认保存位置在 <code>~/.ssh</code> 目录下，打开后会看到私钥文件 <code>id_rsa</code> 和公钥文件 <code>id_rsa.pub</code>；</li>
</ul>
<h2 id="2复制公钥至服务器">2.复制公钥至服务器</h2>
<ul>
<li>
<p>通过宝塔面板直接将<code>~/.ssh/id_rsa.pub</code>配置到服务器的<code>~/.ssh/authorized_keys</code>文件中</p>
</li>
<li>
<p>使用 scp 命令将本地的公钥文件 <code>id_rsa.pub</code> 复制到需要连接的Linux服务器：</p>
<pre><code class="language-bash">scp ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-bash">scp -P &lt;端口号&gt; ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>把公钥追加到服务器ssh认证文件中:</p>
<pre><code class="language-bash">cat /home/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
</li>
<li>
<p>这时候在本地终端中使用用户名和ip登录就不需要密码了：</p>
<pre><code class="language-xml">ssh &lt;用户名&gt;@&lt;ip&gt;
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-xml">ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;ip地址&gt;
</code></pre>
</li>
</ul>
<h2 id="3配置快捷登录">3.配置快捷登录</h2>
<ul>
<li>在本地 <code>~/.ssh/config</code> 配置文件中添加ssh服务器信息（可多个），格式：</li>
</ul>
<blockquote>
<pre><code class="language-ruby">Host            alias            #自定义别名
HostName        hostname         #替换为你的ssh服务器ip或domain
Port            port             #ssh服务器端口，默认为22
User            user             #ssh服务器用户名
IdentityFile    ~/.ssh/id_rsa    #第一个步骤生成的公钥文件对应的私钥文件
</code></pre>
</blockquote>
<ul>
<li>配置成功后，即可直接通过<code>ssh alias</code>登录</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序页面跳转的一系列注意点]]></title>
        <id>https://pxygogogo.github.io/post/nagivation-problems/</id>
        <link href="https://pxygogogo.github.io/post/nagivation-problems/">
        </link>
        <updated>2020-02-13T11:34:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>showModel 回调无法跳转除TabBar之外的页面</p>
<ul>
<li>回调中只能使用switchTab进行跳转</li>
</ul>
</li>
<li>
<p>switchTab跳转后页面不刷新</p>
<ul>
<li>
<p>法一：switchTab成功跳转后调用success,此时可以拿到跳转后页面的page对象,从而调用页面onLoad方法重载页面</p>
<pre><code class="language-javascript">wx.switchTab({
    url: '/pages/index/index',
    success: function(e) {
        let page = getCurrentPages().pop();
        if (page == undefined || page == null) return;
        page.onLoad();
    }
})
</code></pre>
</li>
<li>
<p>法二：当switchTab点击过的时候，只有第一次加载数据，第二次点击的时候是不刷新数据的，这个时候只要在需要每次点击都需要刷新数据的TabBar页的js里加上onShow的方法即可</p>
<pre><code class="language-javascript"> onShow:function(e){
       this.onLoad();
 },
</code></pre>
</li>
</ul>
</li>
<li>
<p>TabBar页面只能使用switchTab跳转</p>
<ul>
<li>文档里有写，使用时需注意</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js for in 和 for of 区别及遍历相关注意点]]></title>
        <id>https://pxygogogo.github.io/post/js-iterator/</id>
        <link href="https://pxygogogo.github.io/post/js-iterator/">
        </link>
        <updated>2020-01-02T03:02:41.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>例一</li>
</ul>
<pre><code>const obj = {
        a: 1,
        b: 2,
        c: 3
    }
    for (let i in obj) {
        console.log(i)
        // a
        // b
        // c
    }
    for (let i of obj) {
        console.log(i)
        // Uncaught TypeError: obj is not iterable 报错了
    }
</code></pre>
<p>以上代码通过 for in 和 for of 对一个obj对象进行遍历,for in 正常的获取了对象的 key值,分别打印 a、b、c,而 for of却报错了。</p>
<ul>
<li>例二</li>
</ul>
<p>以上是遍历对象,下面再看一个遍历数组的例子。</p>
<pre><code>const arr = ['a', 'b', 'c']
    // for in 循环
    for (let i in arr) {
        console.log(i)
        // 0
        // 1
        // 2
    }
    
    // for of
    for (let i of arr) {
        console.log(i)
        // a
        // b
        // c
    }
</code></pre>
<p>以上代码是对一个数组进行遍历, for in 返回的值为 0、1、2,返回的是数组的下标，而 for of 返回的是 a、b、c,返回的是数组的值</p>
<p>结合上面两个例子，分析得出</p>
<h2 id="for-in-特点">for in 特点</h2>
<ul>
<li>
<p>for ... in 循环返回的值都是数据结构的 键值名。<br>
遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。</p>
</li>
<li>
<p>for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——例3</p>
</li>
<li>
<p>特别情况下, for ... in 循环会以任意的顺序遍历键名</p>
</li>
</ul>
<blockquote>
<p>注：使用for in 遍历对象是无法直接获取属性值得，因为他实际上遍历的是对象中的可枚举属性，你需要手动获取属性值</p>
<p>遍历数组下标时采用的是数组顺序（for循环或者其他迭代器），但是遍历对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样。因此在不同的环境中需要保证一致性时，不用相信任何观察到的顺序，它们是不可靠的</p>
<p>（引用自你不知道的JavaScript上卷）</p>
</blockquote>
<h2 id="for-of-特点">for of 特点</h2>
<ul>
<li>
<p>for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名</p>
</li>
<li>
<p>一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。</p>
</li>
<li>
<p>例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterable</p>
</li>
<li>
<p>for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。</p>
</li>
<li>
<p>提供了遍历所有数据结构的统一接口</p>
</li>
</ul>
<blockquote>
<p>for of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来手动遍历数组，看看它是怎么工作的</p>
</blockquote>
<pre><code>var arr = [1,2,3];
var it = arr[Symbpl.iterator]();

it.next(); // {value:1,done:false}
it.next(); // {value:2,done:false}
it.next(); // {value:3,done:false}
it.next(); // {done:true}
</code></pre>
<h2 id="哪些数据结构部署了-symboliteratoer属性了呢">哪些数据结构部署了 Symbol.iteratoer属性了呢?</h2>
<p>只要有 iterator 接口的数据结构,都可以使用 for of循环。</p>
<ul>
<li>数组 Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>arguments对象</li>
<li>Nodelist对象, 就是获取的dom列表集合<br>
以上这些都可以直接使用 for of 循环。 凡是部署了 iterator 接口的数据结构也都可以使用数组的 扩展运算符(...)、和解构赋值等操作。</li>
</ul>
<p>我也想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of</p>
<p>以例1为例</p>
<pre><code> const obj = {
        a: 1,
        b: 2,
        c: 3
    }

    for (let i of Object.keys(obj)) {
        console.log(i)
        // 1
        // 2
        // 3
    }
</code></pre>
<p>也可以给一个对象部署 Symbol.iterator属性。</p>
<ul>
<li>当你为对象添加myObject.toString()方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加myObjectSymbol.iterator方法，就可以遍历这个对象了。</li>
</ul>
<p>举个例子，假设你正在使用jQuery，尽管你非常钟情于里面的.each()方法，但你还是想让jQuery对象也支持for-of循环，你可以这样做：</p>
<pre><code>jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
</code></pre>
<p>所有拥有Symbol.iterator的对象被称为可迭代的。在接下来的文章中你会发现，可迭代对象的概念几乎贯穿于整门语言之中，不仅是for-of循环，还有Map和Set构造函数、解构赋值，以及新的展开操作符。</p>
<ul>
<li>for...of的步骤<br>
for-of循环首先调用集合的Symbol.iterator方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next()方法的对象；for-of循环将重复调用这个方法，每次循环调用一次。</li>
</ul>
<blockquote>
<p>和组数不同，普通的对象没有内置的@@iterator，所以无法自动完成for of遍历。之所以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型<br>
当然，你可以给任何想遍历的对象定义@@iterator，举例来说：</p>
</blockquote>
<pre><code>var myObject = {
        a: { x: 2 },
        b: 3
    };
    Object.defineProperty(myObject, Symbol.iterator, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: function () {
            var o = this;
            var idx = 0;
            var ks = Object.keys(o);
            return {
                next: function () {
                    return {
                        value: o[ks[idx++]],
                        done: (idx &gt; ks.length)
                    };
                }
            };
        }
    });

    // 手动遍历myObject
    var it = myObject[Symbol.iterator]();
    console.log(it.next()); //{value:2,done:false}  
    console.log(it.next()); //{value:e,done:false}
    console.log(it.next()); //{value:undefined,done:true}

    //用 for of 遍历myObject
    for (var v of myObject) {
        console.log(v);
    }
    // 2
    // 3
</code></pre>
<p>参考文章：</p>
<blockquote>
<p>链接：<br>
你不知道的JavaScript上卷3.4节<br>
https://www.jianshu.com/p/c43f418d6bf0<br>
https://www.cnblogs.com/owenzh/p/11058708.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js实现深浅拷贝]]></title>
        <id>https://pxygogogo.github.io/post/js-copy/</id>
        <link href="https://pxygogogo.github.io/post/js-copy/">
        </link>
        <updated>2020-01-01T13:01:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现浅拷贝">实现浅拷贝</h2>
<ul>
<li>一、...实现</li>
</ul>
<pre><code>let copy = {...{a:1}};
</code></pre>
<ul>
<li>二、(ES6)Object.assign实现</li>
</ul>
<pre><code>let copy = Object.assign({},{a:1});
</code></pre>
<h2 id="实现深拷贝">实现深拷贝</h2>
<ul>
<li>一、JSON.stringify()/JSON.parse()实现</li>
</ul>
<pre><code>let obj = {a: 1, b: {x: 3}};
let deepCopy = JSON.parse(JSON.stringify(obj));
</code></pre>
<p><mark>注：这种方法实施的前提必须是实施的对象是JSON安全的</mark></p>
<ul>
<li>二、递归拷贝</li>
</ul>
<pre><code>function deepClone(obj) {
    let copy = obj.instanceof Arrary ? [] : {};
    for (let i in obj) {
        if(obj.hasOwnProperty(i)) {
            copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
        }
    }
    return copy
}

</code></pre>
]]></content>
    </entry>
</feed>