<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pxygogogo.github.io</id>
    <title>小潘的博客</title>
    <updated>2020-03-11T04:40:58.353Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pxygogogo.github.io"/>
    <link rel="self" href="https://pxygogogo.github.io/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://pxygogogo.github.io/images/avatar.png</logo>
    <icon>https://pxygogogo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[Mongoose得到的对象不能增加属性解决方法（两种）]]></title>
        <id>https://pxygogogo.github.io/post/mongoose-query/</id>
        <link href="https://pxygogogo.github.io/post/mongoose-query/">
        </link>
        <updated>2020-03-11T04:39:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实例">实例</h2>
<ul>
<li>Notice模型文件如下：</li>
</ul>
<pre><code>const mongoose = require('mongoose');

const schema = mongoose.Schema({
    userId:{type:String},
    time: {type:String},
    medicines: {type:Array},
    noticePerson:{type:String},
    acrtTime:{type:String},
});

module.exports = mongoose.model('Notice',schema);
</code></pre>
<ul>
<li>路由响应如下：</li>
</ul>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            result.email = email; //无法生效
            res.send(result);
        }
    });
</code></pre>
<ul>
<li>问题描述：<br>
希望向得到的result数据中添加一个email属性，但直接添加无法成功</li>
</ul>
<hr>
<h2 id="原因">原因</h2>
<ul>
<li>因为Mongoose是個ODM (Object Document Mapper)，类似于操作关系型数据库使用的ORM(Object Relational Mapper)，我们使用Mongoose取到的数据的结构是要依赖于我们定义的schema结构的。增加的email属性在schema中没有定义，所以我们在取到的结果中增加email属性是无效的</li>
</ul>
<hr>
<h2 id="解决办法">解决办法</h2>
<ul>
<li>解决办法一</li>
</ul>
<p><mark>在schema中直接增加需要补充的属性</mark></p>
<p>在本例中即向Notice模型中添加一个email字段</p>
<ul>
<li>解决办法二</li>
</ul>
<p><mark>把查询到的结果clone一个对象，然后在新对象中补充属性</mark></p>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            const data = {
                ...result._doc,
                email,
            };
            res.send(data);
        }
    });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssh 免密码快速登录（MacOs）]]></title>
        <id>https://pxygogogo.github.io/post/ssh-login/</id>
        <link href="https://pxygogogo.github.io/post/ssh-login/">
        </link>
        <updated>2020-03-05T11:47:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建秘钥文件">1.创建秘钥文件</h2>
<ul>
<li>打开终端，执行 ssh-keygen 命令创建密钥对：</li>
</ul>
<blockquote>
<pre><code class="language-bash">ssh-keygen -t rsa -C 'your email@domain.com'
-t 指定密钥类型，默认即 rsa ，可以省略
-C 设置注释文字，比如你的邮箱，可以省略
</code></pre>
</blockquote>
<ul>
<li>生成过程中会提示输入密码两次，如果不想在使用公钥的时候输入密码，可以回车跳过；<br>
密钥默认保存位置在 <code>~/.ssh</code> 目录下，打开后会看到私钥文件 <code>id_rsa</code> 和公钥文件 <code>id_rsa.pub</code>；</li>
</ul>
<h2 id="2复制公钥至服务器">2.复制公钥至服务器</h2>
<ul>
<li>
<p>通过宝塔面板直接将<code>~/.ssh/id_rsa.pub</code>配置到服务器的<code>~/.ssh/authorized_keys</code>文件中</p>
</li>
<li>
<p>使用 scp 命令将本地的公钥文件 <code>id_rsa.pub</code> 复制到需要连接的Linux服务器：</p>
<pre><code class="language-bash">scp ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-bash">scp -P &lt;端口号&gt; ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>把公钥追加到服务器ssh认证文件中:</p>
<pre><code class="language-bash">cat /home/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
</li>
<li>
<p>这时候在本地终端中使用用户名和ip登录就不需要密码了：</p>
<pre><code class="language-xml">ssh &lt;用户名&gt;@&lt;ip&gt;
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-xml">ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;ip地址&gt;
</code></pre>
</li>
</ul>
<h2 id="3配置快捷登录">3.配置快捷登录</h2>
<ul>
<li>在本地 <code>~/.ssh/config</code> 配置文件中添加ssh服务器信息（可多个），格式：</li>
</ul>
<blockquote>
<pre><code class="language-ruby">Host            alias            #自定义别名
HostName        hostname         #替换为你的ssh服务器ip或domain
Port            port             #ssh服务器端口，默认为22
User            user             #ssh服务器用户名
IdentityFile    ~/.ssh/id_rsa    #第一个步骤生成的公钥文件对应的私钥文件
</code></pre>
</blockquote>
<ul>
<li>配置成功后，即可直接通过<code>ssh alias</code>登录</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序页面跳转的一系列注意点]]></title>
        <id>https://pxygogogo.github.io/post/nagivation-problems/</id>
        <link href="https://pxygogogo.github.io/post/nagivation-problems/">
        </link>
        <updated>2020-02-13T11:34:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>showModel 回调无法跳转除TabBar之外的页面</p>
<ul>
<li>回调中只能使用switchTab进行跳转</li>
</ul>
</li>
<li>
<p>switchTab跳转后页面不刷新</p>
<ul>
<li>
<p>法一：switchTab成功跳转后调用success,此时可以拿到跳转后页面的page对象,从而调用页面onLoad方法重载页面</p>
<pre><code class="language-javascript">wx.switchTab({
    url: '/pages/index/index',
    success: function(e) {
        let page = getCurrentPages().pop();
        if (page == undefined || page == null) return;
        page.onLoad();
    }
})
</code></pre>
</li>
<li>
<p>法二：当switchTab点击过的时候，只有第一次加载数据，第二次点击的时候是不刷新数据的，这个时候只要在需要每次点击都需要刷新数据的TabBar页的js里加上onShow的方法即可</p>
<pre><code class="language-javascript"> onShow:function(e){
       this.onLoad();
 },
</code></pre>
</li>
</ul>
</li>
<li>
<p>TabBar页面只能使用switchTab跳转</p>
<ul>
<li>文档里有写，使用时需注意</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
</feed>