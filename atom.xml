<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-06-28T15:57:39.415Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[git从已有分支拉取新分支]]></title>
        <id>https://xiayun.im/post/git-branch/</id>
        <link href="https://xiayun.im/post/git-branch/">
        </link>
        <updated>2020-06-28T15:38:30.000Z</updated>
        <content type="html"><![CDATA[<p>开发过程中经常用到从master分支copy一个开发分支</p>
<ol>
<li>切换到被copy的分支（master），并且从远端拉取最新版本</li>
</ol>
<pre><code class="language-bash">git checkout master

git pull
</code></pre>
<ol start="2">
<li>从当前分支拉copy开发分支</li>
</ol>
<pre><code class="language-bash">git checkout -b dev
// 提示 Switched to a new branch 'dev'
</code></pre>
<ol start="3">
<li>把新建的分支push到远端</li>
</ol>
<pre><code class="language-bash">git push origin dev
</code></pre>
<ol start="4">
<li>拉取远端分支</li>
</ol>
<pre><code>git pull
</code></pre>
<p>提示：</p>
<pre><code class="language-bash">There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

git branch --set-upstream-to=origin/&lt;branch&gt; dev
</code></pre>
<p>经过验证，当前的分支并没有和本地分支关联，根据提示进行下一步：</p>
<ol start="5">
<li>关联</li>
</ol>
<pre><code class="language-bash">git branch --set-upstream-to=origin/dev
</code></pre>
<blockquote>
<p>注意：这里branch之后都是没有空格的，如果有空格则是错误命令</p>
</blockquote>
<ol start="6">
<li>再次拉取 验证</li>
</ol>
<pre><code>git pull
</code></pre>
<p>done</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to fetch data with React Hooks（转）]]></title>
        <id>https://xiayun.im/post/how-to-fetch-data-with-react-hooks/</id>
        <link href="https://xiayun.im/post/how-to-fetch-data-with-react-hooks/">
        </link>
        <updated>2020-06-21T14:11:32.000Z</updated>
        <content type="html"><![CDATA[<p>How to fetch data with React Hooks？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React哲学]]></title>
        <id>https://xiayun.im/post/react-philosophy/</id>
        <link href="https://xiayun.im/post/react-philosophy/">
        </link>
        <updated>2020-06-17T12:41:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一步将设计好的-ui-划分为组件层级">第一步：将设计好的 UI 划分为组件层级</h2>
<p>如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</p>
<h2 id="第二步用-react-创建一个静态版本">第二步：用 React 创建一个静态版本</h2>
<p>现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。</p>
<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。</p>
<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</p>
<blockquote>
<p>单向数据流</p>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>
<p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中</p>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件</p>
</blockquote>
<h2 id="第三步确定-ui-state-的最小且完整表示">第三步：确定 UI state 的最小（且完整）表示</h2>
<p>为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY: Don’t Repeat Yourself</a>。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p>
<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<h2 id="第四步确定-state-放置的位置">第四步：确定 state 放置的位置</h2>
<p>我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。</p>
<p>对于应用中的每一个 state：</p>
<ol>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ol>
<h2 id="第五步添加反向数据流">第五步：添加反向数据流</h2>
<p>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</p>
<p>本文由react官方文档整理而得</p>
<p><a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks之在比对中执行effects]]></title>
        <id>https://xiayun.im/post/react-hooks-excute-effects/</id>
        <link href="https://xiayun.im/post/react-hooks-excute-effects/">
        </link>
        <updated>2020-06-11T04:50:34.000Z</updated>
        <content type="html"><![CDATA[<p>React 针对 React Elements 前后值进行对比，只去更新 DOM 真正发生改变的部分。对于 Effects，能否有类似这样的理念呢？</p>
<p>某个 Effects 函数一旦执行，函数内的副作用已经发生，React 无法猜测到函数相比于上一次做了哪些变化。但我们可以给 useEffect 传入第二个参数，作为依赖数组 (deps)，避免 Effects 不必要的重复调用。<br>
这个 deps 的含义是：当前 Effect 依赖了哪些变量。</p>
<p>实际应用中，我们不需要在每次组件更新时，都去执行某些 effects，这个时候我们可以给 useEffect 设置依赖，告诉 React 什么时候去执行 useEffect</p>
<p>但有时问题不一定能解决。比如官网就有<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often"> 这样的例子:</a></p>
<pre><code class="language-jsx">const [count, setCount] = useState(0);

useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
}, [count]);


</code></pre>
<p>如果我们频繁修改 count，每次执行 Effect，上一次的计时器被清除，需要调用 setInterval 重新进入时间队列，实际的定期时间被延后，甚至有可能根本没有机会被执行。</p>
<p>但是下面这样的实践方式也不宜采用：</p>
<p>在 Effect 函数中寻找一些变量添加到 deps 中，需要满足条件：其变化时，需要重新触发 effect。</p>
<p>按照这种实践方式，count 变化时，我们并不希望重新 setInterval，故 deps 为空数组。这意味着该 hook 只在组件挂载时运行一次。Effect 中明明依赖了 count，但我们撒谎说它没有依赖，那么当 setInterval 回调函数执行时，获取到的 count 值永远为 0。</p>
<p>遇到这种问题，直接从 deps 移除是不可行的。静下来分析一下，此处为什么要用到 count？能否避免对其直接使用？</p>
<p>可以看到，在 setCount 中用到了 count，为的是把 count 转换为 count + 1 ，然后返回给 React。React 其实已经知道当前的 count，我们需要告知 React 的仅仅是去递增状态，不管它现在具体是什么值。</p>
<p>所以有一个最佳实践：状态变更时，应该通过 setState 的函数形式来代替直接获取当前状态。</p>
<pre><code>setCount(c =&gt; c + 1);
</code></pre>
<p>另外一种场景是：</p>
<pre><code class="language-jsx">const [count, setCount] = useState(0);

useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        console.log(count);
    }, 1000);
    return () =&gt; clearInterval(id);
}, []);
</code></pre>
<p>复制代码在这里，同样的，当count 变化时，我们并不希望重新 setInterval。但我们可以把 count 通过 ref 保存起来。</p>
<pre><code class="language-jsx">const [count, setCount] = useState(0);
const countRef = useRef();
countRef.current = count;

useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        console.log(countRef.current);
    }, 1000);
    return () =&gt; clearInterval(id);
}, []);
</code></pre>
<p>复制代码这样，count 的确不再被使用，而是用 ref 存储了一个在所有帧中共享的变量。</p>
<p>另外的情况是，Effects 依赖了函数或者其他引用类型。与原始数据类型不同的是，在未优化的情况下，每次 render 函数调用时，因为对这些内容的重新创建，其值总是发生了变化，导致 Effects 在使用 deps 的情况下依然会频繁被调用。</p>
<p>对于这个问题，<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">官网的 FAQ </a>已经给出了答案：对于函数，使用 useCallback 避免重复创建；对于对象或者数组，则可以使用 useMemo。从而减少 deps 的变化。</p>
<blockquote>
<p><a href="https://juejin.im/post/5ec7372cf265da76de5cd0c9">原文链接</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks之每一次渲染都有它自己的effects]]></title>
        <id>https://xiayun.im/post/react-hooks-effects/</id>
        <link href="https://xiayun.im/post/react-hooks-effects/">
        </link>
        <updated>2020-06-10T03:20:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react-hooks之每一次渲染都有它自己的effects">React Hooks之每一次渲染都有它自己的effects</h3>
<p>同样通过一个例子来说明：</p>
<pre><code class="language-js">function Counter() {
  const [count, setCount] = useState(0)

  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(`You clicked ${count} times`)
    }, 3000)
  })

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>点击 3 次按钮：</p>
<p>分析：<br>
整个过程组件进行了四次渲染：</p>
<blockquote>
<p>初始化，render0：打印 You clicked 0 times；</p>
<p>修改 count 值为1，render1：打印 You clicked 1 times；</p>
<p>修改 count 值为2，render2：打印 You clicked 2 times；</p>
<p>修改 count 值为3，render3：打印 You clicked 3 times；</p>
<p>通过整个例子我们可以知道，在每次渲染中，useEffect 也是独立的。</p>
</blockquote>
<p>并不是count的值在“不变”的effect中发生了改变，而是effect 函数本身在每一次渲染中都不相同。</p>
<p>每一个effect版本“看到”的count值都来自于它属于的那次渲染：</p>
<pre><code class="language-js">// During first render
function Counter() {
  // ...
  useEffect(
    // Effect function from first render
    setTimeout(() =&gt; {
      console.log(`You clicked ${0} times`)
    }, 3000)
  );
  // ...
}

// After a click, our function is called again
function Counter() {
  // ...
  useEffect(
    // Effect function from second render
    setTimeout(() =&gt; {
      console.log(`You clicked ${1} times`)
    }, 3000)
  );
  // ...
}

// After another click, our function is called again
function Counter() {
  // ...
  useEffect(
    // Effect function from third render
    setTimeout(() =&gt; {
      console.log(`You clicked ${2} times`)
    }, 3000)
  );
  // ..
}

// After another click, our function is called again
function Counter() {
  // ...
  useEffect(
    // Effect function from forth render
    setTimeout(() =&gt; {
      console.log(`You clicked ${3} times`)
    }, 3000)
  );
  // ..
}

</code></pre>
<h3 id="清除-effect">清除 effect</h3>
<p>在 React class 中，你通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它。当我们在 useEffect 中使用了定时器或者添加了某些订阅，可以通过 useEffect 返回一个函数，进行清除定时器或者取消订阅等操作。</p>
<p>看一下例子，在 useEffect 中打印点击的次数：</p>
<pre><code class="language-js">function Example() {
  const [count, setCount] = useState(0)

  useEffect(() =&gt; {
    console.log(`You clicked ${count} times`)
    return() =&gt; {
      console.log('销毁')
    }
  })

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  )

</code></pre>
<p>点击按钮 3 次，控制台中打印的结果如下：</p>
<p>You clicked 0 times<br>
销毁<br>
You clicked 1 times<br>
销毁<br>
You clicked 2 times<br>
销毁<br>
You clicked 3 times</p>
<p>从打印结果我们可以很容易看出，上一次的 effect 是在重新渲染时被清除的。</p>
<p>补充：那么组件的整个重新渲染的过程是怎么样的呢？<br>
假设现在有 render0 和 render1 两次渲染：</p>
<p>React 渲染 render1 的UI;<br>
浏览器绘制，并呈现 render1 的UI；<br>
React 清除 render0 的 effect；<br>
React 运行 render1 的 effect；</p>
<blockquote>
<p>React 只会在浏览器绘制后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks之每一次渲染都有它自己的 Props and State和事件处理函数]]></title>
        <id>https://xiayun.im/post/react-hooks/</id>
        <link href="https://xiayun.im/post/react-hooks/">
        </link>
        <updated>2020-06-10T02:40:23.000Z</updated>
        <content type="html"><![CDATA[<p>React Hooks之每一次渲染都有它自己的 Props and State和事件处理函数,就我个人角度，我将它简单的理解成为一个快照</p>
<h3 id="通过一个例子来说明">通过一个例子来说明：</h3>
<pre><code class="language-js">export default function Example(props) {
  const [times, setTimes] = useState(0);
  const handleClick = () =&gt; {
    setTimeout(() =&gt; {
      alert(`example--${props.count}`);
      setTimes(times + 1);
    }, 3000);
  };
  return (
    &lt;&gt;
      &lt;h1&gt;Example&lt;/h1&gt;
      &lt;p&gt;props.count---{props.count}&lt;/p&gt;
      &lt;p&gt;state.times---{times}&lt;/p&gt;
      &lt;button onClick={handleClick}&gt;alert count&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>重点关注 <Example> 函数组件的代码，其中的 count 属性由父组件传入，初始值为 0，每隔一秒增加 1。点击 &quot;alert count&quot; 按钮，将延迟 3 秒钟弹出 count 的值。<mark>操作后发现，弹窗中出现的值，与页面中文本展示的值不同，而是等于点击 &quot;alert Count&quot; 按钮时 count 的值</mark>。</p>
<p>其中的times属性是组件自身的state，初始值为0，点击 &quot;alert count&quot; 按钮，将延迟 3 秒钟 + 1。如果我在3s内，多次点击按钮，最终它的值并不会是上一次的times值+点击次数*1而是上一次的times+1，这说明只要当点击事件触发时那一刻的times的值没有发生改变，那么无论你在3s内点击多少次，它都是一样的结果。</p>
<p>其点击的快照类似如此：</p>
<pre><code class="language-js">// 第一次点击后3s内的所有点击快照
const handleClick = () =&gt; {
    setTimeout(() =&gt; {
      alert(`example--点击时的props.count`);
      setTimes(0 + 1);
    }, 3000);
  };
</code></pre>
<p>如果更换为 class 组件，它的实现是 <Example2> 这样的：</p>
<pre><code class="language-js">
class Example2 extends Component {
  constructor(props) {
    super(props);
    this.state = {
      times: 0
    };
  }
  handleClick = () =&gt; {
    setTimeout(() =&gt; {
      alert(`example2--${this.props.count}`);
      this.setState({
        times: this.state.times + 1
      });
    }, 3000);
  };
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Example2&lt;/h1&gt;
        &lt;p&gt;{this.props.count}&lt;/p&gt;
        &lt;p&gt;{this.state.times}&lt;/p&gt;
        &lt;button onClick={this.handleClick}&gt;alert count&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

</code></pre>
<p>此时，点击 &quot;alert count&quot; 按钮，延迟 3 秒钟弹出 count 的值，与页面中文本展示的值是一样的。<br>
在某些情况下，<Example> 函数组件中的行为才符合预期。如果将 setTimeout 类比到一次 Fetch 请求，在请求成功时，我要获取的是发起 Fetch 请求前相关的数据，并对其进行修改。</p>
<p>其中的times属性是组件自身的state，初始值为0，点击 &quot;alert count&quot; 按钮，将延迟 3 秒钟 + 1。如果我在3s内，多次点击按钮，最终它的值始终会是上一次的times+1，与hooks组件的表现不一。</p>
<h3 id="如何理解其中的差异">如何理解其中的差异？</h3>
<p>在 <Example2> class 组件中，我们是从 this 中获取到的 props.count。this 是固定指向同一个组件实例的。在 3 秒的延时器生效后，组件重新进行了渲染，this.props 也发生了改变。当延时的回调函数执行时，读取到的 this.props 是当前组件最新的属性值。<br>
而在 <Example> 函数组件中，每一次执行 render 函数时，props 作为该函数的参数传入，它是函数作用域下的变量。</p>
<p>由于 props 是 Example 函数作用域下的变量，可以说对于这个函数的每一次调用中，都产生了新的 props 变量，它在声明时被赋予了当前的属性，他们相互间互不影响。<br>
换一种说法，对于其中任一个 props ，其值在声明时便已经决定，不会随着时间产生变化。handleClick 函数亦是如此。例如定时器的回调函数是在未来发生的，但 props.count 的值是在声明 handleClick 函数时就已经决定好的。</p>
<h3 id="结论">结论：</h3>
<p>在任意一次渲染中，props和state是始终保持不变的。如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的count值。</p>
<p><a href="https://codesandbox.io/s/react-hookszhimeiyicixuanranduyoutazijide-props-and-stateheshijianchulihanshu-syhjb?file=/src/index.js">edit on codesandbox</a></p>
<blockquote>
<p>参考文章：</p>
<p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p>
<p><a href="https://juejin.im/post/5ec7372cf265da76de5cd0c9">React Hooks 最佳实践</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你喜欢哪种朋友——余光中]]></title>
        <id>https://xiayun.im/post/friends/</id>
        <link href="https://xiayun.im/post/friends/">
        </link>
        <updated>2020-06-07T04:31:25.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一个人命里不见得有太太或丈夫但绝对不可没有朋友-即使是荒岛上的鲁滨逊也不免需要一个礼拜五-一个人不能选择父母但是除了鲁滨逊之外每个人都可以选择自己的朋友-照理说选来的东西应该符合自己的理想才对-但是事实又不尽然">一个人命里不见得有太太或丈夫，但绝对不可没有朋友。即使是荒岛上的鲁滨逊，也不免需要一个“礼拜五”。一个人不能选择父母，但是除了鲁滨逊之外，每个人都可以选择自己的朋友。照理说选来的东西，应该符合自己的理想才对。但是事实又不尽然。</h5>
<h5 id="你选别人别人也选你-被选是一种荣誉但不一定是一件乐事-来按你门铃的人很多岂能人人都让你喜出望外呢大致来说按铃的人可分为下列四型">你选别人，别人也选你。被选，是一种荣誉，但不一定是一件乐事。来按你门铃的人很多，岂能人人都让你“喜出望外”呢？大致来说，按铃的人可分为下列四型：</h5>
<h5 id="第一型高级而有趣">第一型，高级而有趣。</h5>
<h5 id="这种朋友理想是理想只是可遇不可求">这种朋友理想是理想，只是可遇不可求。</h5>
<h5 id="世界上高级的人很多有趣的人也很多又高级又有趣的人却少之又少-高级的人使人尊敬有趣的人使人喜欢又高级又有趣的人使人敬而不畏亲而不狎交接愈久芬芳愈醇-譬如新鲜的水果不但甘美可口而且富于营养可谓一举两得-朋友是自己的镜子-一个人有了这样的朋友自己的境界也低不到哪里去-东坡先生杖履所至几曾出现过低级而无趣的俗物呢">世界上高级的人很多，有趣的人也很多，又高级又有趣的人却少之又少。高级的人使人尊敬，有趣的人使人喜欢，又高级又有趣的人，使人敬而不畏，亲而不狎，交接愈久，芬芳愈醇。譬如新鲜的水果，不但甘美可口，而且富于营养，可谓一举两得。朋友是自己的镜子。一个人有了这样的朋友，自己的境界也低不到哪里去。东坡先生杖履所至，几曾出现过低级而无趣的俗物呢。</h5>
<h5 id="第二型高级而无趣">第二型，高级而无趣。</h5>
<h5 id="这种人大概就是古人所谓的诤友甚至是畏友了">这种人大概就是古人所谓的诤友，甚至是畏友了。</h5>
<h5 id="这种朋友有的知识丰富有的人格高超有的呢品学兼优像个模范生可惜美中不足都缺乏一点幽默感活泼不起来-你总觉得他身上有一个窍没打通因此无法豁然恍然具备充分的现实感-跟他交谈即不像打球那样你来我往此呼彼应也不像滚雪球那样把一个有趣的话题越滚越大-精力过人的一类只管自己发球不管你接不接得住-消极的一类则以逸待劳难得接你一球两球-无论对手消极积极总之该你捡球你不捡球这场球是别想打下去的-这种畏友的遗憾在于趣味太窄所以跟你的接触面广不起来-天下之大他从城南跑到城北来找你的目的只在讨论死亡在法国现代小说的特殊意义-为这种畏友捡一晚上的球疲劳是可以想见的-这样的友谊有点像吃药太苦了一点">这种朋友，有的知识丰富，有的人格高超，有的呢，“品学兼优”像个模范生，可惜美中不足，都缺乏一点幽默感，活泼不起来。你总觉得，他身上有一个窍没打通，因此无法豁然恍然，具备充分的现实感。跟他交谈，即不像打球那样，你来我往，此呼彼应，也不像滚雪球那样，把一个有趣的话题越滚越大。精力过人的一类，只管自己发球，不管你接不接得住。消极的一类则以逸待劳，难得接你一球两球。无论对手消极积极，总之该你捡球，你不捡球，这场球是别想打下去的。这种畏友的遗憾，在于趣味太窄，所以跟你的“接触面”广不起来。天下之大，他从城南跑到城北来找你的目的，只在讨论“死亡在法国现代小说的特殊意义”。为这种畏友捡一晚上的球，疲劳是可以想见的。这样的友谊有点像吃药，太苦了一点。</h5>
<h5 id="第三型低级而有趣">第三型，低级而有趣。</h5>
<h5 id="这种朋友极富娱乐价值说笑话他最黄说故事他最像消息他最灵通关系他最广阔好去处他都去过坏主意他都打过-世界上任何话题他都接得下去至于怎么接法就不用你操心了">这种朋友极富娱乐价值，说笑话，他最黄；说故事，他最像；消息，他最灵通；关系，他最广阔；好去处，他都去过；坏主意，他都打过。世界上任何话题他都接得下去，至于怎么接法，就不用你操心了。</h5>
<p>他的全部学问，就在于不让外行人听出他没有学问。至于内行人，世界上有多少内行人呢？所以他的马脚在许多客厅和餐厅里跑来跑去，并不怎么露眼。这种人最会说话，餐桌上有了他，一定宾主尽欢，大家喝进去的美酒还不如听进去的美言那么“沁人心脾”。会议上有了他，再空洞的会议也会显得主题正确，内容充沛，没有白开。如果说，第二类的朋友拥有世界上全部的学问，独缺常识，那么这一型的朋友则恰恰相反，拥有世界上全部的常识，独缺知识。照说低级的人而有趣味，岂非低级趣味，你竟能于他同乐，岂非也有低级趣味之嫌？不过人性是广阔的，谁能保证自己毫无此种不良的成分呢？</p>
<h5 id="如果要你做鲁滨逊你会选第三型的朋友还是第二型的朋友做礼拜五呢">如果要你做鲁滨逊，你会选第三型的朋友还是第二型的朋友做“礼拜五”呢？</h5>
<h5 id="第四型低级而无趣">第四型，低级而无趣。</h5>
<h5 id="这种朋友跟第一型的朋友一样少或然率相当之低">这种朋友，跟第一型的朋友一样少，或然率相当之低。</h5>
<h5 id="这种人当然自有一套价值标准非但不会承认自己低级而无趣恐怕还自以为高级而有趣呢否则余不欲于之同乐矣">这种人当然自有一套价值标准，非但不会承认自己低级而无趣，恐怕还自以为高级而有趣呢？否则，余不欲于之同乐矣。</h5>
<h5 id="亲爱的朋友你是第几型">亲爱的朋友你是第几型？</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给我的孩子们——丰子恺]]></title>
        <id>https://xiayun.im/post/to-my-child/</id>
        <link href="https://xiayun.im/post/to-my-child/">
        </link>
        <updated>2020-05-20T15:19:43.000Z</updated>
        <content type="html"><![CDATA[<p>我的孩子们！我憧憬于你们的生活，每天不止一次！我想委曲地说出来，使你们自己晓得。可惜到你们懂得我的话的意思的时候，你们将不复是可以使我憧憬的人了。这是何等可悲哀的事啊！</p>
<p>瞻瞻！你尤其可佩服。你是身心全部公开的真人。你甚么事体（什么事情）都想拼命地用全副精力去对付。小小的失意，象花生米翻落地了，自己嚼了舌头了，小猫不肯吃糕了，你都要哭得嘴唇翻白，昏去一两分钟。外婆普陀去烧香买回来给你的泥人，你何等鞠躬尽瘁地抱他，喂他；有一天你自己失手把他打破了，你的号哭的悲哀，比大人们的破产、失恋、丧考妣、全军覆没的悲哀都要真切。两把芭蕉扇做的脚踏车，麻雀牌堆成的火车、汽车，你何等认真地看待，挺直了嗓子叫“汪——，”“咕咕咕……”，来代替汽油。宝姊姊讲故事给你听，说到“月亮姊姊挂下一只篮来，宝姊姊坐在篮里吊了上去，瞻瞻在下面看”的时候，你何等激昂地同她争，说“瞻瞻要上去，宝姊姊在下面看！”甚至哭到漫姑面前去求审判。我每次剃了头，你真心地疑我变了和尚，好几时不要我抱。最是今年夏天，你坐在我膝上发现了我腋下的长毛，当作黄鼠狼的时候，你何等伤心，你立刻从我身上爬下去，起初眼瞪瞪地对我端相，继而大失所望地号哭，看看，哭哭，如同对被判定了死罪的亲友一样。你要我抱你到车站里去，多多益善地要买香蕉，满满地擒了两手回来，回到门口时你已经熟睡在我的肩上，手里的香蕉不知落在哪里去了。这是何等可佩服的真率、自然与热情！大人间的所谓“沉默”、“含蓄”、“深刻”的美德，比起你来，全是不自然的、病的、伪的！</p>
<p>你们每天做火车、做汽车、办酒、请菩萨、堆六面画，唱歌、全是自动的，创造创作的生活。大人们的呼号“归自然！”“生活的艺术化！”“劳动的艺术化！”在你们面前真是出丑得很了！依样画几笔画，写几篇文的人称为艺术家、创作家，对你们更要愧死！</p>
<p>你们的创作力，比大人真是强盛得多哩：瞻瞻！你的身体不及椅子的一半，却常常要搬动它，与它一同翻倒在地上；你又要把一杯茶横转来藏在抽斗里，要皮球停在壁上，要拉住火车的尾巴，要月亮出来，要天停止下雨。在这等小小的事件中，明明表示着你们的弱小的体力与智力不足以应付强盛的创作欲、表现欲的驱使，因而遭逢失败。然而你们是不受大自然的支配，不受人类社会的束缚的创造者，所以你的遭逢失败，例如火车尾巴拉不住，月亮呼不出来的时候，你们决不承认是事实的不可能，总以为是爹爹妈妈不肯帮你们办到，同不许你们弄自鸣钟同例，所以愤愤地哭了，你们的世界何等广大！</p>
<p>你们一定想：终天无聊地伏在案上弄笔的爸爸，终天闷闷地坐在窗下弄引线的妈妈，是何等无气性的奇怪的动物！你们所视为奇怪动物的我与你们的母亲，有时确实难为了你们，摧残了你们，回想起来，真是不安心得很！</p>
<p>阿宝！有一晚你拿软软的新鞋子，和自己脚上脱下来的鞋子，给凳子的脚穿了，刬袜立在地上，得意地叫“阿宝两只脚，凳子四只脚”的时候，你母亲喊着“龌龊了袜子！”立刻擒你到藤榻上，动手毁坏你的创作。当你蹲在榻上注视你母亲动手毁坏的时候，你的小心里一定感到“母亲这种人，何等煞风景而野蛮”罢！</p>
<p>瞻瞻！有一天开明书店送了几册新出版的毛边的《音乐入门》来。我用小刀把书页一张一张地裁开来，你侧着头，站在桌边默默地看。后来我从学校回来，你已经在我的书架上拿了一本连史纸印的中国装的《楚辞》，把它裁破了十几页，得意地对我说：“爸爸！瞻瞻也会裁了！”瞻瞻！这在你原是何等成功的欢喜，何等得意的作品！却被我一个惊骇的“哼！”字喊得你哭了。那时候你也一定抱怨“爸爸何等不明”罢！</p>
<p>软软！你常常要弄我的长锋羊毫，我看见了总是无情地夺脱你。现在你一定轻视我，想道：“你终于要我画你的画集的封面！”</p>
<p>最不安心的，是有时我还要拉一个你们所最怕的陆露沙医生来，叫他用他的大手来摸你们的肚子，甚至用刀来在你们臂上割几下，还要叫妈妈和漫姑擒住了你们的手脚，捏住了你们的鼻子，把很苦的水灌到你们的嘴里去。这在你们一定认为是太无人道的野蛮举动罢！</p>
<p>孩子们！你们果真抱怨我，我倒欢喜；到你们的抱怨变为感激的时候，我的悲哀来了！</p>
<p>我在世间，永没有逢到象你们这样出肺肝相示的人。世间的人群结合，永没有象你们样的彻底地真实而纯洁。最是我到上海去干了无聊的所谓“事”回来，或者去同不相干的人们做了叫做“上课”的一种把戏回来，你们在门口或车站旁等我的时候，我心中何等惭愧又欢喜！惭愧我为甚么去做这等无聊的事，欢喜我又得暂时放怀一切地加入你们的真生活的团体。</p>
<p>但是，你们的黄金时代有限，现实终于要暴露的。这是我经验过来的情形也是大人们谁也经验过的情形。我眼看见儿时的伴侣中的英雄、好汉，一个个退缩、顺从、妥协、屈服起来，到象绵羊的地步。我自己也是如此。“后之视今，亦犹今之视昔”，你们不久也要走这条路呢？</p>
<p>我的孩子们！憧憬于你们的生活的我，痴心要为你们永远挽留这黄金时代在这册子里。</p>
<p>然这真不过象“蜘蛛网落花”，略微保留一点春的痕迹而已。且到你们懂得我这片心情的时候，你们早已不是这样的人，我的画在世间已无可印证了！这是何等可悲哀的事啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react中通过props给子组件传值，父组件setState后props不能同步更新的问题]]></title>
        <id>https://xiayun.im/post/react-props-state/</id>
        <link href="https://xiayun.im/post/react-props-state/">
        </link>
        <updated>2020-05-20T14:48:59.000Z</updated>
        <content type="html"><![CDATA[<p>一、业务场景</p>
<p>父组件给子组件一个数据列表后，增删改都在子组件中进行</p>
<p>实现思路：父组件将数据列表以props的形式传递给子组件，子组件将这个props赋值给自身的state，之后的增删改就更新自身的state值，以实现局部刷新。</p>
<p>二、一个demo实现</p>
<p><mark>强烈推荐使用codesandbox.io进行demo操作</mark></p>
<pre><code class="language-js">import { render } from 'react-dom'
import React from 'react'

class Child extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: props.list
    }
  }

  handleCilck = () =&gt; {
    this.setState({
      list: this.state.list.concat({ name: 'sarah' })
    })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleCilck}&gt;添加&lt;/button&gt;
        {this.state.list.map((item, index) =&gt; {
          return &lt;h1 key={index}&gt;Hello, {item.name}&lt;/h1&gt;
        })}
      &lt;/div&gt;
    )
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: [{ name: 'lily' }, { name: 'bob' }]
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Child list={this.state.list} /&gt;;
      &lt;/div&gt;
    )
  }
}

render(&lt;Parent /&gt;, document.getElementById('root'))
</code></pre>
<p><strong>这个demo会产生一个问题，如果父组件传递给子组件的props改变了，子组件渲染的列表数据却不会对应发生改变。</strong></p>
<p>原因：父组件更新导致子组件更新时，子组件的生命周期执行顺序如下：</p>
<pre><code class="language-js">componentWillReceiveProps(UNSAFE_componentWillReceiveProps) 
// componentWillReceiveProps is deprecated since React 16.9.0, use UNSAFE_componentWillReceiveProps instead
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate
</code></pre>
<p><mark><strong>也就是说子组件刷新的时候，父组件传递给子组件的props发生改变，引发子组件的render，并没有执行子组件的constructor函数，子组件没有被卸载自然不会重新加载，只会重新render，而如果父组件的props传递给子组件的state，那么子组件的state只会在第一次加载的时候被赋值，后续的父组件props变化并不会被赋值到子组件的state上，还是要理解组件的声明周期函数，以及各个函数在什么时候会被调用。</strong></mark></p>
<p>解决方案：在UNSAFE_componentWillReceiveProps中重新对state赋值。</p>
<pre><code class="language-js">UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      list: nextProps.list
    })
}

</code></pre>
<p>接着给子组件添加修改功能</p>
<p>js部分:</p>
<pre><code class="language-js">handleModify = () =&gt; {
    let newArray = this.state.list
    newArray[0].name = 'natasha'
    this.setState({
      list: newArray
    })
  }
</code></pre>
<p>jsx部分:</p>
<pre><code class="language-html">&lt;button onClick={this.handleAdd}&gt;添加&lt;/button&gt;
</code></pre>
<p>如果直接这样做又会引发一个新的问题</p>
<p>因为list是引用类型，这样更改的话，不仅更改了子组件自身的state，还更改了父组件传递进来的props，也就是父组件的state.list的值。</p>
<p>因此在更改引用类型的数据时，应该采用浅拷贝或者深拷贝的方式</p>
<p>三、总结</p>
<p>总结以上demo实践，父组件用props赋值给子组件的state时，需要注意两点：</p>
<p>1.在生命周期UNSAFE_componentWillReceiveProps中重新赋值</p>
<p>2.用深拷贝创建不可变类型引用数据</p>
<blockquote>
<p>react官方文档讲的挺好</p>
<p>参考资料：</p>
<p><a href="https://www.azimiao.com/6316.html">文章一</a></p>
<p><a href="https://www.jianshu.com/p/19c4dc3394f0">文章二</a></p>
<p><a href="https://segmentfault.com/q/1010000008387645">文章三</a></p>
<p><a href="https://blog.csdn.net/RuiKe1400360107/article/details/89554600">文章四</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react setState修改嵌套对象]]></title>
        <id>https://xiayun.im/post/react-setstate-complex-datastruct/</id>
        <link href="https://xiayun.im/post/react-setstate-complex-datastruct/">
        </link>
        <updated>2020-05-19T14:39:52.000Z</updated>
        <content type="html"><![CDATA[<p>在开发过程中,时常会在state中遇到一些比较复杂的数据结构,类似下面这样的:</p>
<pre><code class="language-js">state = {
     list: {
        objA: {
          name: 'A',
          age: 20
        },
        objB: {
          name: 'B',
          age: 25
        },
        objC: {
          show: false
        },
        objD: 'D'
      }
}
</code></pre>
<p>这时需要我们修改list中objA中的name属性和objD的属性,遇到这样的情况我们一般会使用什么办法解决呢?其实有三种解决方案:</p>
<h3 id="方案一作用于对象中的深层级和第一层级">方案一(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">this.setState({
     list: {
         ...this.state.list,
          objA: {
            ...this.state.list.objA,
            name: 'A1'
            }
        }
    })
</code></pre>
<h3 id="方案二作用对象中的第一层级">方案二(作用对象中的第一层级):</h3>
<pre><code class="language-js">    let data = Object.assign({}, this.state.list, {objD: 'D1'})
    this.setState({
        list: data
    })
</code></pre>
<h3 id="方案三作用于对象中的深层级和第一层级">方案三(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">    let data = this.state.list;
    data.objA.name = 'A1';
    data.objD = 'D1';
    this.setState({
        list: data
    })
</code></pre>
<p>总结:</p>
<table>
<thead>
<tr>
<th style="text-align:center">方案</th>
<th style="text-align:center">适用范围</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方案一</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">写法麻烦,单次对象赋值,对象层级多的时候,容易遗漏</td>
</tr>
<tr>
<td style="text-align:center">方案二</td>
<td style="text-align:center">只适用与第一层级</td>
<td style="text-align:center">只适用第一层级</td>
</tr>
<tr>
<td style="text-align:center">方案三</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">若存在深层及和单一层级的,需要多次赋值</td>
</tr>
</tbody>
</table>
<p>这三种写法都可以,使用哪一种方案,还需要根据业务来定</p>
<p><a href="https://blog.csdn.net/weixin_34191845/article/details/89596546?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">原文链接</a></p>
]]></content>
    </entry>
</feed>