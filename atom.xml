<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-06-17T12:42:31.459Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[React哲学]]></title>
        <id>https://xiayun.im/post/react-philosophy/</id>
        <link href="https://xiayun.im/post/react-philosophy/">
        </link>
        <updated>2020-06-17T12:41:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一步将设计好的-ui-划分为组件层级">第一步：将设计好的 UI 划分为组件层级</h2>
<p>如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</p>
<h2 id="第二步用-react-创建一个静态版本">第二步：用 React 创建一个静态版本</h2>
<p>现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。</p>
<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。</p>
<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</p>
<blockquote>
<p>单向数据流</p>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>
<p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中</p>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件</p>
</blockquote>
<h2 id="第三步确定-ui-state-的最小且完整表示">第三步：确定 UI state 的最小（且完整）表示</h2>
<p>为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY: Don’t Repeat Yourself</a>。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p>
<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<h2 id="第四步确定-state-放置的位置">第四步：确定 state 放置的位置</h2>
<p>我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。</p>
<p>对于应用中的每一个 state：</p>
<ol>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ol>
<h2 id="第五步添加反向数据流">第五步：添加反向数据流</h2>
<p>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</p>
<p>本文由react官方文档整理而得</p>
<p><a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React哲学]]></title>
        <id>https://xiayun.im/post/react-zhe-xue/</id>
        <link href="https://xiayun.im/post/react-zhe-xue/">
        </link>
        <updated>2020-06-17T12:41:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一步将设计好的-ui-划分为组件层级">第一步：将设计好的 UI 划分为组件层级</h2>
<p>如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</p>
<h2 id="第二步用-react-创建一个静态版本">第二步：用 React 创建一个静态版本</h2>
<p>现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。</p>
<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。</p>
<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</p>
<blockquote>
<p>单向数据流</p>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>
<p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中</p>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件</p>
</blockquote>
<h2 id="第三步确定-ui-state-的最小且完整表示">第三步：确定 UI state 的最小（且完整）表示</h2>
<p>为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY: Don’t Repeat Yourself</a>。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p>
<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<h2 id="第四步确定-state-放置的位置">第四步：确定 state 放置的位置</h2>
<p>我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。</p>
<p>对于应用中的每一个 state：</p>
<ol>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ol>
<h2 id="第五步添加反向数据流">第五步：添加反向数据流</h2>
<p>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</p>
<p>本文由react官方文档整理而得</p>
<p><a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你喜欢哪种朋友——余光中]]></title>
        <id>https://xiayun.im/post/friends/</id>
        <link href="https://xiayun.im/post/friends/">
        </link>
        <updated>2020-06-07T04:31:25.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一个人命里不见得有太太或丈夫但绝对不可没有朋友-即使是荒岛上的鲁滨逊也不免需要一个礼拜五-一个人不能选择父母但是除了鲁滨逊之外每个人都可以选择自己的朋友-照理说选来的东西应该符合自己的理想才对-但是事实又不尽然">一个人命里不见得有太太或丈夫，但绝对不可没有朋友。即使是荒岛上的鲁滨逊，也不免需要一个“礼拜五”。一个人不能选择父母，但是除了鲁滨逊之外，每个人都可以选择自己的朋友。照理说选来的东西，应该符合自己的理想才对。但是事实又不尽然。</h5>
<h5 id="你选别人别人也选你-被选是一种荣誉但不一定是一件乐事-来按你门铃的人很多岂能人人都让你喜出望外呢大致来说按铃的人可分为下列四型">你选别人，别人也选你。被选，是一种荣誉，但不一定是一件乐事。来按你门铃的人很多，岂能人人都让你“喜出望外”呢？大致来说，按铃的人可分为下列四型：</h5>
<h5 id="第一型高级而有趣">第一型，高级而有趣。</h5>
<h5 id="这种朋友理想是理想只是可遇不可求">这种朋友理想是理想，只是可遇不可求。</h5>
<h5 id="世界上高级的人很多有趣的人也很多又高级又有趣的人却少之又少-高级的人使人尊敬有趣的人使人喜欢又高级又有趣的人使人敬而不畏亲而不狎交接愈久芬芳愈醇-譬如新鲜的水果不但甘美可口而且富于营养可谓一举两得-朋友是自己的镜子-一个人有了这样的朋友自己的境界也低不到哪里去-东坡先生杖履所至几曾出现过低级而无趣的俗物呢">世界上高级的人很多，有趣的人也很多，又高级又有趣的人却少之又少。高级的人使人尊敬，有趣的人使人喜欢，又高级又有趣的人，使人敬而不畏，亲而不狎，交接愈久，芬芳愈醇。譬如新鲜的水果，不但甘美可口，而且富于营养，可谓一举两得。朋友是自己的镜子。一个人有了这样的朋友，自己的境界也低不到哪里去。东坡先生杖履所至，几曾出现过低级而无趣的俗物呢。</h5>
<h5 id="第二型高级而无趣">第二型，高级而无趣。</h5>
<h5 id="这种人大概就是古人所谓的诤友甚至是畏友了">这种人大概就是古人所谓的诤友，甚至是畏友了。</h5>
<h5 id="这种朋友有的知识丰富有的人格高超有的呢品学兼优像个模范生可惜美中不足都缺乏一点幽默感活泼不起来-你总觉得他身上有一个窍没打通因此无法豁然恍然具备充分的现实感-跟他交谈即不像打球那样你来我往此呼彼应也不像滚雪球那样把一个有趣的话题越滚越大-精力过人的一类只管自己发球不管你接不接得住-消极的一类则以逸待劳难得接你一球两球-无论对手消极积极总之该你捡球你不捡球这场球是别想打下去的-这种畏友的遗憾在于趣味太窄所以跟你的接触面广不起来-天下之大他从城南跑到城北来找你的目的只在讨论死亡在法国现代小说的特殊意义-为这种畏友捡一晚上的球疲劳是可以想见的-这样的友谊有点像吃药太苦了一点">这种朋友，有的知识丰富，有的人格高超，有的呢，“品学兼优”像个模范生，可惜美中不足，都缺乏一点幽默感，活泼不起来。你总觉得，他身上有一个窍没打通，因此无法豁然恍然，具备充分的现实感。跟他交谈，即不像打球那样，你来我往，此呼彼应，也不像滚雪球那样，把一个有趣的话题越滚越大。精力过人的一类，只管自己发球，不管你接不接得住。消极的一类则以逸待劳，难得接你一球两球。无论对手消极积极，总之该你捡球，你不捡球，这场球是别想打下去的。这种畏友的遗憾，在于趣味太窄，所以跟你的“接触面”广不起来。天下之大，他从城南跑到城北来找你的目的，只在讨论“死亡在法国现代小说的特殊意义”。为这种畏友捡一晚上的球，疲劳是可以想见的。这样的友谊有点像吃药，太苦了一点。</h5>
<h5 id="第三型低级而有趣">第三型，低级而有趣。</h5>
<h5 id="这种朋友极富娱乐价值说笑话他最黄说故事他最像消息他最灵通关系他最广阔好去处他都去过坏主意他都打过-世界上任何话题他都接得下去至于怎么接法就不用你操心了">这种朋友极富娱乐价值，说笑话，他最黄；说故事，他最像；消息，他最灵通；关系，他最广阔；好去处，他都去过；坏主意，他都打过。世界上任何话题他都接得下去，至于怎么接法，就不用你操心了。</h5>
<p>他的全部学问，就在于不让外行人听出他没有学问。至于内行人，世界上有多少内行人呢？所以他的马脚在许多客厅和餐厅里跑来跑去，并不怎么露眼。这种人最会说话，餐桌上有了他，一定宾主尽欢，大家喝进去的美酒还不如听进去的美言那么“沁人心脾”。会议上有了他，再空洞的会议也会显得主题正确，内容充沛，没有白开。如果说，第二类的朋友拥有世界上全部的学问，独缺常识，那么这一型的朋友则恰恰相反，拥有世界上全部的常识，独缺知识。照说低级的人而有趣味，岂非低级趣味，你竟能于他同乐，岂非也有低级趣味之嫌？不过人性是广阔的，谁能保证自己毫无此种不良的成分呢？</p>
<h5 id="如果要你做鲁滨逊你会选第三型的朋友还是第二型的朋友做礼拜五呢">如果要你做鲁滨逊，你会选第三型的朋友还是第二型的朋友做“礼拜五”呢？</h5>
<h5 id="第四型低级而无趣">第四型，低级而无趣。</h5>
<h5 id="这种朋友跟第一型的朋友一样少或然率相当之低">这种朋友，跟第一型的朋友一样少，或然率相当之低。</h5>
<h5 id="这种人当然自有一套价值标准非但不会承认自己低级而无趣恐怕还自以为高级而有趣呢否则余不欲于之同乐矣">这种人当然自有一套价值标准，非但不会承认自己低级而无趣，恐怕还自以为高级而有趣呢？否则，余不欲于之同乐矣。</h5>
<h5 id="亲爱的朋友你是第几型">亲爱的朋友你是第几型？</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给我的孩子们——丰子恺]]></title>
        <id>https://xiayun.im/post/to-my-child/</id>
        <link href="https://xiayun.im/post/to-my-child/">
        </link>
        <updated>2020-05-20T15:19:43.000Z</updated>
        <content type="html"><![CDATA[<p>我的孩子们！我憧憬于你们的生活，每天不止一次！我想委曲地说出来，使你们自己晓得。可惜到你们懂得我的话的意思的时候，你们将不复是可以使我憧憬的人了。这是何等可悲哀的事啊！</p>
<p>瞻瞻！你尤其可佩服。你是身心全部公开的真人。你甚么事体（什么事情）都想拼命地用全副精力去对付。小小的失意，象花生米翻落地了，自己嚼了舌头了，小猫不肯吃糕了，你都要哭得嘴唇翻白，昏去一两分钟。外婆普陀去烧香买回来给你的泥人，你何等鞠躬尽瘁地抱他，喂他；有一天你自己失手把他打破了，你的号哭的悲哀，比大人们的破产、失恋、丧考妣、全军覆没的悲哀都要真切。两把芭蕉扇做的脚踏车，麻雀牌堆成的火车、汽车，你何等认真地看待，挺直了嗓子叫“汪——，”“咕咕咕……”，来代替汽油。宝姊姊讲故事给你听，说到“月亮姊姊挂下一只篮来，宝姊姊坐在篮里吊了上去，瞻瞻在下面看”的时候，你何等激昂地同她争，说“瞻瞻要上去，宝姊姊在下面看！”甚至哭到漫姑面前去求审判。我每次剃了头，你真心地疑我变了和尚，好几时不要我抱。最是今年夏天，你坐在我膝上发现了我腋下的长毛，当作黄鼠狼的时候，你何等伤心，你立刻从我身上爬下去，起初眼瞪瞪地对我端相，继而大失所望地号哭，看看，哭哭，如同对被判定了死罪的亲友一样。你要我抱你到车站里去，多多益善地要买香蕉，满满地擒了两手回来，回到门口时你已经熟睡在我的肩上，手里的香蕉不知落在哪里去了。这是何等可佩服的真率、自然与热情！大人间的所谓“沉默”、“含蓄”、“深刻”的美德，比起你来，全是不自然的、病的、伪的！</p>
<p>你们每天做火车、做汽车、办酒、请菩萨、堆六面画，唱歌、全是自动的，创造创作的生活。大人们的呼号“归自然！”“生活的艺术化！”“劳动的艺术化！”在你们面前真是出丑得很了！依样画几笔画，写几篇文的人称为艺术家、创作家，对你们更要愧死！</p>
<p>你们的创作力，比大人真是强盛得多哩：瞻瞻！你的身体不及椅子的一半，却常常要搬动它，与它一同翻倒在地上；你又要把一杯茶横转来藏在抽斗里，要皮球停在壁上，要拉住火车的尾巴，要月亮出来，要天停止下雨。在这等小小的事件中，明明表示着你们的弱小的体力与智力不足以应付强盛的创作欲、表现欲的驱使，因而遭逢失败。然而你们是不受大自然的支配，不受人类社会的束缚的创造者，所以你的遭逢失败，例如火车尾巴拉不住，月亮呼不出来的时候，你们决不承认是事实的不可能，总以为是爹爹妈妈不肯帮你们办到，同不许你们弄自鸣钟同例，所以愤愤地哭了，你们的世界何等广大！</p>
<p>你们一定想：终天无聊地伏在案上弄笔的爸爸，终天闷闷地坐在窗下弄引线的妈妈，是何等无气性的奇怪的动物！你们所视为奇怪动物的我与你们的母亲，有时确实难为了你们，摧残了你们，回想起来，真是不安心得很！</p>
<p>阿宝！有一晚你拿软软的新鞋子，和自己脚上脱下来的鞋子，给凳子的脚穿了，刬袜立在地上，得意地叫“阿宝两只脚，凳子四只脚”的时候，你母亲喊着“龌龊了袜子！”立刻擒你到藤榻上，动手毁坏你的创作。当你蹲在榻上注视你母亲动手毁坏的时候，你的小心里一定感到“母亲这种人，何等煞风景而野蛮”罢！</p>
<p>瞻瞻！有一天开明书店送了几册新出版的毛边的《音乐入门》来。我用小刀把书页一张一张地裁开来，你侧着头，站在桌边默默地看。后来我从学校回来，你已经在我的书架上拿了一本连史纸印的中国装的《楚辞》，把它裁破了十几页，得意地对我说：“爸爸！瞻瞻也会裁了！”瞻瞻！这在你原是何等成功的欢喜，何等得意的作品！却被我一个惊骇的“哼！”字喊得你哭了。那时候你也一定抱怨“爸爸何等不明”罢！</p>
<p>软软！你常常要弄我的长锋羊毫，我看见了总是无情地夺脱你。现在你一定轻视我，想道：“你终于要我画你的画集的封面！”</p>
<p>最不安心的，是有时我还要拉一个你们所最怕的陆露沙医生来，叫他用他的大手来摸你们的肚子，甚至用刀来在你们臂上割几下，还要叫妈妈和漫姑擒住了你们的手脚，捏住了你们的鼻子，把很苦的水灌到你们的嘴里去。这在你们一定认为是太无人道的野蛮举动罢！</p>
<p>孩子们！你们果真抱怨我，我倒欢喜；到你们的抱怨变为感激的时候，我的悲哀来了！</p>
<p>我在世间，永没有逢到象你们这样出肺肝相示的人。世间的人群结合，永没有象你们样的彻底地真实而纯洁。最是我到上海去干了无聊的所谓“事”回来，或者去同不相干的人们做了叫做“上课”的一种把戏回来，你们在门口或车站旁等我的时候，我心中何等惭愧又欢喜！惭愧我为甚么去做这等无聊的事，欢喜我又得暂时放怀一切地加入你们的真生活的团体。</p>
<p>但是，你们的黄金时代有限，现实终于要暴露的。这是我经验过来的情形也是大人们谁也经验过的情形。我眼看见儿时的伴侣中的英雄、好汉，一个个退缩、顺从、妥协、屈服起来，到象绵羊的地步。我自己也是如此。“后之视今，亦犹今之视昔”，你们不久也要走这条路呢？</p>
<p>我的孩子们！憧憬于你们的生活的我，痴心要为你们永远挽留这黄金时代在这册子里。</p>
<p>然这真不过象“蜘蛛网落花”，略微保留一点春的痕迹而已。且到你们懂得我这片心情的时候，你们早已不是这样的人，我的画在世间已无可印证了！这是何等可悲哀的事啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react中通过props给子组件传值，父组件setState后props不能同步更新的问题]]></title>
        <id>https://xiayun.im/post/react-props-state/</id>
        <link href="https://xiayun.im/post/react-props-state/">
        </link>
        <updated>2020-05-20T14:48:59.000Z</updated>
        <content type="html"><![CDATA[<p>一、业务场景</p>
<p>父组件给子组件一个数据列表后，增删改都在子组件中进行</p>
<p>实现思路：父组件将数据列表以props的形式传递给子组件，子组件将这个props赋值给自身的state，之后的增删改就更新自身的state值，以实现局部刷新。</p>
<p>二、一个demo实现</p>
<p><mark>强烈推荐使用codesandbox.io进行demo操作</mark></p>
<pre><code class="language-js">import { render } from 'react-dom'
import React from 'react'

class Child extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: props.list
    }
  }

  handleCilck = () =&gt; {
    this.setState({
      list: this.state.list.concat({ name: 'sarah' })
    })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleCilck}&gt;添加&lt;/button&gt;
        {this.state.list.map((item, index) =&gt; {
          return &lt;h1 key={index}&gt;Hello, {item.name}&lt;/h1&gt;
        })}
      &lt;/div&gt;
    )
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: [{ name: 'lily' }, { name: 'bob' }]
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Child list={this.state.list} /&gt;;
      &lt;/div&gt;
    )
  }
}

render(&lt;Parent /&gt;, document.getElementById('root'))
</code></pre>
<p><strong>这个demo会产生一个问题，如果父组件传递给子组件的props改变了，子组件渲染的列表数据却不会对应发生改变。</strong></p>
<p>原因：父组件更新导致子组件更新时，子组件的生命周期执行顺序如下：</p>
<pre><code class="language-js">componentWillReceiveProps(UNSAFE_componentWillReceiveProps) 
// componentWillReceiveProps is deprecated since React 16.9.0, use UNSAFE_componentWillReceiveProps instead
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate
</code></pre>
<p><mark><strong>也就是说子组件刷新的时候，父组件传递给子组件的props发生改变，引发子组件的render，并没有执行子组件的constructor函数，子组件没有被卸载自然不会重新加载，只会重新render，而如果父组件的props传递给子组件的state，那么子组件的state只会在第一次加载的时候被赋值，后续的父组件props变化并不会被赋值到子组件的state上，还是要理解组件的声明周期函数，以及各个函数在什么时候会被调用。</strong></mark></p>
<p>解决方案：在UNSAFE_componentWillReceiveProps中重新对state赋值。</p>
<pre><code class="language-js">UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      list: nextProps.list
    })
}

</code></pre>
<p>接着给子组件添加修改功能</p>
<p>js部分:</p>
<pre><code class="language-js">handleModify = () =&gt; {
    let newArray = this.state.list
    newArray[0].name = 'natasha'
    this.setState({
      list: newArray
    })
  }
</code></pre>
<p>jsx部分:</p>
<pre><code class="language-html">&lt;button onClick={this.handleAdd}&gt;添加&lt;/button&gt;
</code></pre>
<p>如果直接这样做又会引发一个新的问题</p>
<p>因为list是引用类型，这样更改的话，不仅更改了子组件自身的state，还更改了父组件传递进来的props，也就是父组件的state.list的值。</p>
<p>因此在更改引用类型的数据时，应该采用浅拷贝或者深拷贝的方式</p>
<p>三、总结</p>
<p>总结以上demo实践，父组件用props赋值给子组件的state时，需要注意两点：</p>
<p>1.在生命周期UNSAFE_componentWillReceiveProps中重新赋值</p>
<p>2.用深拷贝创建不可变类型引用数据</p>
<blockquote>
<p>react官方文档讲的挺好</p>
<p>参考资料：</p>
<p><a href="https://www.azimiao.com/6316.html">文章一</a></p>
<p><a href="https://www.jianshu.com/p/19c4dc3394f0">文章二</a></p>
<p><a href="https://segmentfault.com/q/1010000008387645">文章三</a></p>
<p><a href="https://blog.csdn.net/RuiKe1400360107/article/details/89554600">文章四</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react setState修改嵌套对象]]></title>
        <id>https://xiayun.im/post/react-setstate-complex-datastruct/</id>
        <link href="https://xiayun.im/post/react-setstate-complex-datastruct/">
        </link>
        <updated>2020-05-19T14:39:52.000Z</updated>
        <content type="html"><![CDATA[<p>在开发过程中,时常会在state中遇到一些比较复杂的数据结构,类似下面这样的:</p>
<pre><code class="language-js">state = {
     list: {
        objA: {
          name: 'A',
          age: 20
        },
        objB: {
          name: 'B',
          age: 25
        },
        objC: {
          show: false
        },
        objD: 'D'
      }
}
</code></pre>
<p>这时需要我们修改list中objA中的name属性和objD的属性,遇到这样的情况我们一般会使用什么办法解决呢?其实有三种解决方案:</p>
<h3 id="方案一作用于对象中的深层级和第一层级">方案一(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">this.setState({
     list: {
         ...this.state.list,
          objA: {
            ...this.state.list.objA,
            name: 'A1'
            }
        }
    })
</code></pre>
<h3 id="方案二作用对象中的第一层级">方案二(作用对象中的第一层级):</h3>
<pre><code class="language-js">    let data = Object.assign({}, this.state.list, {objD: 'D1'})
    this.setState({
        list: data
    })
</code></pre>
<h3 id="方案三作用于对象中的深层级和第一层级">方案三(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">    let data = this.state.list;
    data.objA.name = 'A1';
    data.objD = 'D1';
    this.setState({
        list: data
    })
</code></pre>
<p>总结:</p>
<table>
<thead>
<tr>
<th style="text-align:center">方案</th>
<th style="text-align:center">适用范围</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方案一</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">写法麻烦,单次对象赋值,对象层级多的时候,容易遗漏</td>
</tr>
<tr>
<td style="text-align:center">方案二</td>
<td style="text-align:center">只适用与第一层级</td>
<td style="text-align:center">只适用第一层级</td>
</tr>
<tr>
<td style="text-align:center">方案三</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">若存在深层及和单一层级的,需要多次赋值</td>
</tr>
</tbody>
</table>
<p>这三种写法都可以,使用哪一种方案,还需要根据业务来定</p>
<p><a href="https://blog.csdn.net/weixin_34191845/article/details/89596546?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react复制内容到剪切板]]></title>
        <id>https://xiayun.im/post/copy-to-clipboard/</id>
        <link href="https://xiayun.im/post/copy-to-clipboard/">
        </link>
        <updated>2020-05-18T14:31:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react-copy-to-clipboard插件">react-copy-to-clipboard插件</h3>
<p>一个react插件，npm安装即可。<br>
优点：查看官方示例，上手简单，兼容性扩展性会比较强<br>
缺点：截止发文，最新版5.0.2版包大小达到了37.2kb，对于一个在项目中使用不多的需求有些浪费。</p>
<h3 id="原生js实现">原生js实现</h3>
<h4 id="documentexeccommand方法">document.execCommand()方法</h4>
<p><a href="hhttps://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">MDN上定义：</a></p>
<p>当一个HTML文档切换到设计模式时，document暴露 execCommand 方法，该方法允许运行命令来操纵<mark>可编辑内容区域</mark>的元素。</p>
<p>再看可编辑内容区域（contenteditable）的定义</p>
<p>全局属性 contenteditable  是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。</p>
<p>也就是意味着除了 <mark><input>、<textarea></mark> 这样的输入域以外，是无法使用这个方法的</p>
<p>如果是需要获取input和textarea的值然后复制的，可以直接通过获取元素节点后通过select方法选中后直接调用document.execCommand('copy')即可</p>
<p>样例：</p>
<pre><code class="language-js">    const btn = document.querySelector('#btn');
    btn.addEventListener('click',() =&gt; {
        const input = document.createElement('input');
        input.setAttribute('readonly', 'readonly');
        input.setAttribute('value', 'hello world!');
        document.body.appendChild(input);
        input.select();
        if (document.execCommand('copy')) {
            document.execCommand('copy');
            console.log('复制成功');
        }
        document.body.removeChild(input);
    })
</code></pre>
<blockquote>
<p>如果需要隐藏新创建的元素时需要注意不能通过设置display值为none来实现，因为设置为none后将无法获取元素的属性值包括value，上一篇文章仔细探讨了display：none和visibility：hidden区别</p>
</blockquote>
<h4 id="createtextrange">createTextRange()</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range">MDN上对于range定义：</a></p>
<p>Range 接口表示一个包含节点与文本节点的一部分的文档片段。</p>
<p>可以用 Document 对象的 Document.createRange 方法创建 Range，也可以用 Selection 对象的 getRangeAt 方法获取 Range。另外，还可以通过 Document 对象的构造函数 Range() 来得到 Range</p>
<p>其原理与上种方法大同小异</p>
<p>样例：</p>
<pre><code class="language-js">        var div = document.getElementById('div1');
        if (document.body.createTextRange) {
            var range = document.body.createTextRange();
            range.moveToElementText(div);
            range.select();
        } else if (window.getSelection) {
            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(div);
            selection.removeAllRanges();
            selection.addRange(range);
        } else {
            console.warn(&quot;none&quot;);
        }
        document.execCommand(&quot;copy&quot;)
</code></pre>
<p><a href="https://www.cnblogs.com/dch0/p/12674129.html">参考一</a></p>
<p><a href="https://www.jb51.net/article/135605.htm">参考二</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[display none与visibility hidden的区别]]></title>
        <id>https://xiayun.im/post/display-visibility/</id>
        <link href="https://xiayun.im/post/display-visibility/">
        </link>
        <updated>2020-05-18T14:30:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>面试题常考，以为自己足够理解，但第一次在真实场景中使用还是<br>
没有注意，记录之，自省！</p>
</blockquote>
<h2 id="联系它们都能让元素不可见">联系：它们都能让元素不可见</h2>
<h2 id="区别">区别：</h2>
<h3 id="其一">其一</h3>
<ul>
<li>display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；</li>
<li>visibility: hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见</li>
</ul>
<h3 id="其二">其二</h3>
<ul>
<li>visibility:hidden; 使用该属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。</li>
<li>display:none; 使用该属性后，HTML元素（对象）的权度、高度等各种属性值都将“丢失”。</li>
</ul>
<h3 id="其三">其三</h3>
<ul>
<li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；</li>
<li>visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显示</li>
</ul>
<h3 id="其四">其四</h3>
<p>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</p>
<h3 id="其五">其五</h3>
<p>读屏器不会读取display: none;元素内容,会读取visibility: hidden;元素内容</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react中获取属性的问题]]></title>
        <id>https://xiayun.im/post/react-get-attribute/</id>
        <link href="https://xiayun.im/post/react-get-attribute/">
        </link>
        <updated>2020-05-13T14:12:40.000Z</updated>
        <content type="html"><![CDATA[<p>react 获取属性的问题，currentTarget确实是可以的，target确实是有问题的</p>
<p>父节点有属性data-cc 这时候点击父节点获取属性</p>
<p>正确方式是 event.currentTarget.getAttribute(“data-cc”)</p>
<p>而不是event.target.getAttribute(“data-cc”)</p>
<p>ps:</p>
<p>currentTarget 返回其事件监听器触发该事件的元素。 target 返回触发此事件的元素（事件的目标节点）。<br>
react添加自定义属性必须是 data-xx 形式<br>
最简单直白理解event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素</p>
<p>关于currentTarget和target详细区别见下篇文章</p>
<p><a href="https://blog.csdn.net/fortunegrant/article/details/83754945">原文地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[package.json和package-lock.json的区别]]></title>
        <id>https://xiayun.im/post/package.json-package.lock.json/</id>
        <link href="https://xiayun.im/post/package.json-package.lock.json/">
        </link>
        <updated>2020-05-11T14:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>package.json:</p>
<p>主要用来定义项目中需要依赖的包</p>
<p>package-lock.json：</p>
<p>根据官方文档，package-lock.json是生成的系统当前安装的库的具体来源和版本号，锁定版本。在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</p>
<p>当你执行npm install的时候， node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，node是从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。</p>
<p>当package.json与package-lock.json都不存在，执行&quot;npm install&quot;时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件，此时，你可以通过&quot;npm init --yes&quot;来生成package.json文件</p>
<p>参考：https://blog.csdn.net/u013992330/java/article/details/81110018</p>
]]></content>
    </entry>
</feed>