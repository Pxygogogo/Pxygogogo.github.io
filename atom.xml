<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-05-11T14:36:51.711Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[css踩坑之z-index]]></title>
        <id>https://xiayun.im/post/css-z-index/</id>
        <link href="https://xiayun.im/post/css-z-index/">
        </link>
        <updated>2020-05-11T14:36:28.000Z</updated>
        <content type="html"><![CDATA[<p>z-index 属性指定一个元素的堆叠顺序<br>
拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面</p>
<p><mark>注意！！！： z-index 只适用于已定位的元素(position:absolute, position:relative, or position:fixed)</mark></p>
<p>所以z-index是一种依赖属性，依赖position属性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux和Flux]]></title>
        <id>https://xiayun.im/post/redux-and-flux/</id>
        <link href="https://xiayun.im/post/redux-and-flux/">
        </link>
        <updated>2020-05-11T14:35:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="flux">Flux</h2>
<h3 id="flux-优点">Flux 优点</h3>
<ul>
<li><strong>最重要的就是“<mark>单向数据流</mark>”的管理方式</strong>。在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</li>
</ul>
<p>解决的MVC的问题:</p>
<blockquote>
<p>MVC最大的问题就是无法禁绝View和Model之间的直接对话，对应于MVC中View就是Flux中的View，对应于MVC中的Model的就是Flux中的Store，在Flux中，Store只有get方法，没有set方法，根本可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action对象给Dispatcher</p>
</blockquote>
<h3 id="flux-不足">Flux 不足</h3>
<ol>
<li>Store之间依赖关系</li>
<li>难以进行服务器端渲染</li>
<li>Store混杂了逻辑和状态</li>
</ol>
<h2 id="redux">Redux</h2>
<p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p>
<p>Flux的基本原则是“单向数据流”,</p>
<p>Redux在此基础上强调三个基本原则：</p>
<ul>
<li>唯一数据源（Single Source of Truth）；</li>
</ul>
<p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。这个唯一Store上的状态，是一个树形的对象，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题</p>
<ul>
<li>保持状态只读（State is read-only）；</li>
</ul>
<p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p>
<ul>
<li>数据改变只能通过纯函数完成（Changes are made with pure functions）。</li>
</ul>
<p>这里所说的纯函数就是Reducer, Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。就以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer, reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次参数reducer，通过reducer函数完成规约所有元素的功能.</p>
<blockquote>
<p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的UI=render(state)思想完全契合</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux理解]]></title>
        <id>https://xiayun.im/post/redux-learning/</id>
        <link href="https://xiayun.im/post/redux-learning/">
        </link>
        <updated>2020-05-10T03:57:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/05/09/YMT4Hg.jpg" alt="redux工作流程" loading="lazy"></figure>
<ol>
<li>一个比喻：</li>
</ol>
<ul>
<li>component --- 读者</li>
<li>store --- 图书馆</li>
<li>reducer --- 图书管理员</li>
<li>action --- 读者的动作</li>
</ul>
<ol start="2">
<li>流程理解</li>
</ol>
<ul>
<li>所有component的数据状态均来自统一的store中</li>
<li>如果需要更新store中的数据，需要在对应的事件中定义一个action，action就是一个对象，这个对象一般有两个属性，第一个是对action的描述，第二个是要改变的值</li>
<li>action会通过dispatch方法将type和value通过store的自动推送策略直接传递给reducer（虚线的作用）</li>
<li>reducer的两个参数</li>
</ul>
<blockquote>
<p>state：指的是原始仓库里的状态</p>
<p>action: 指的是action新传递的状态</p>
</blockquote>
<ul>
<li>reducer中不能直接修改state，需要深拷贝一个state对象，然后在新的state对象上操作，并最终返回新的state</li>
</ul>
<ol start="3">
<li>注意点</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux小技巧]]></title>
        <id>https://xiayun.im/post/redux-tips/</id>
        <link href="https://xiayun.im/post/redux-tips/">
        </link>
        <updated>2020-05-10T03:56:27.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>把Action Types单独写入一个文件<br>
单独出来的原因：</li>
</ol>
<ul>
<li>这些Types如果不统一管理，不利于大型项目的服用，设置会长生冗余代码。</li>
<li>因为Action里的Type，一定要和Reducer里的type一一对应在，所以这部分代码或字母写错后，浏览器里并没有明确的报错，这给调试带来了极大的困难。</li>
</ul>
<p>例：</p>
<pre><code class="language-js">// 导出 目录：src/store/actionTypes.js
export const  CHANGE_INPUT = 'changeInput'
export const  ADD_ITEM = 'addItem'
export const  DELETE_ITEM = 'deleteItem'

// 引入
import { CHANGE_INPUT , ADD_ITEM , DELETE_ITEM } from './store/actionTypes'
</code></pre>
<ol start="2">
<li>把所有的Redux Action放到一个文件里进行管理</li>
</ol>
<p>例：</p>
<pre><code>// 目录：src/store/actionCreators.js
import {CHANGE_INPUT}  from './actionTypes'

export const changeInputAction = (value)=&gt;({
    type:CHANGE_INPUT,
    value
})
// 引入
import {changeInputAction} from './store/actionCreatores'
changeInputValue(e){
    const action = changeInputAction(e.target.value)
    store.dispatch(action)
}
</code></pre>
<ol start="3">
<li>redux三个小坑</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
<ol start="4">
<li>可选的好方式</li>
</ol>
<ul>
<li>UI和业务逻辑分离</li>
<li>无状s态组件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ThinkPHP5+宝塔+nginx环境下访问路由出现404问题]]></title>
        <id>https://xiayun.im/post/tp5-nigix-404/</id>
        <link href="https://xiayun.im/post/tp5-nigix-404/">
        </link>
        <updated>2020-05-01T14:20:28.000Z</updated>
        <content type="html"><![CDATA[<p>在网站伪静态下添加</p>
<pre><code>location / {
    if (!-e $request_filename){
	      rewrite ^(.*)$ /index.php?s=$1 last; break;
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker创建mysql数据库并导入sql文件]]></title>
        <id>https://xiayun.im/post/docker-mysql/</id>
        <link href="https://xiayun.im/post/docker-mysql/">
        </link>
        <updated>2020-04-23T14:08:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1安装mysql">1.安装mysql</h2>
<h3 id="11-拉取镜像以5726为例">1.1 拉取镜像（以5.7.26为例）</h3>
<pre><code>docker pull mysql:5.7.26
</code></pre>
<h3 id="12-运行容器">1.2 运行容器</h3>
<pre><code>docker run -itd --name mysql-test -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre>
<p>参数说明：</p>
<ul>
<li>-p 3307:3306 ：映射容器服务的 3307 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3307 访问到 MySQL 的服务。</li>
<li>MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。</li>
</ul>
<h2 id="2docker操作mysql创建数据库">2.docker操作mysql创建数据库</h2>
<h3 id="21-确定linux中的docker容器mysql正常运行">2.1 确定linux中的docker容器（mysql）正常运行</h3>
<h3 id="22-执行命令docker-exec-it-容器名称-bash-进入容器bash-即进入到mysql容器中">2.2 执行命令：“docker exec -it 容器名称 bash” 进入容器bash-即进入到mysql容器中</h3>
<h3 id="23-登录mysqlmysql-uroot-p-使用root账号登录mysql">2.3 登录mysql：mysql -uroot -p      使用root账号登录mysql</h3>
<h3 id="24-页面提示输入密码数据root-账号所属密码登录到mysql中">2.4 页面提示输入密码——数据root 账号所属密码，登录到mysql中</h3>
<h3 id="25-create-database-数据库名称-命令创建新数据库">2.5 create database 数据库名称  命令创建新数据库；</h3>
<blockquote>
<p>注：所有的mysql命名末尾一定要加“;”<br>
mysql基本命令：</p>
<p>-h数据库主机<br>
-u用户<br>
-p密码<br>
-P端口号（大写P）</p>
<p>例如：mysql -h127.0.0.1 -uroot -p123456 -P3306<br>
PS:-p密码部分，可以直接指定密码，如果不指定，会提示输入密码。</p>
</blockquote>
<h2 id="3将准备好的sql文件导入到docker中的mysql中">3.将准备好的sql文件导入到docker中的mysql中</h2>
<h3 id="31-备份sql文件存储目录">3.1 备份sql文件存储目录</h3>
<pre><code>/data
</code></pre>
<h3 id="32-查看当前mysql容器名称">3.2 查看当前mysql容器名称</h3>
<pre><code>docker ps
</code></pre>
<h3 id="33-将sql导入mysql">3.3 将sql导入mysql</h3>
<pre><code>docker exec -i mysql5.7 mysql -uroot -p123456 mydb &lt; /data/mydb.sql
</code></pre>
<blockquote>
<p>注：</p>
<p>mydb 为：数据库名</p>
<p>mysql5.7 为：容器名</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MAMP Pro更改文件上传大小限制]]></title>
        <id>https://xiayun.im/post/mamp-pro-settings/</id>
        <link href="https://xiayun.im/post/mamp-pro-settings/">
        </link>
        <updated>2020-04-20T12:10:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>近期由于项目需求，需要上传一些几百MB的文件，但是大文件始终报500错误，连TP5的提示都没给，遂Google一通终得一优解，特此记录。</p>
</blockquote>
<p>主要思路：</p>
<ul>
<li>修改php.ini文件（需为当前项目使用的php版本）</li>
</ul>
<p><mark>（MAMP Pro菜单栏选择File-&gt;Edit Template-&gt;PHP-&gt;选择对应版本即可）</mark></p>
<pre><code>file_uploads = On           ; 是否允许上传文件 On/Off 默认是On
upload_max_filesize = 32M   ; 上传文件的最大限制（改为需求大小即可）
post_max_size = 32M         ; 通过Post提交的最多数据（改为需求大小即可）
</code></pre>
<ul>
<li>考虑网络传输快慢,可以修改一些参数</li>
</ul>
<pre><code>max_execution_time = 30000  ; 脚本最长的执行时间 单位为秒
max_input_time = 600        ; 接收提交的数据的时间限制 单位为秒
memory_limit = 1024M        ; 最大的内存消耗
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css常见单位]]></title>
        <id>https://xiayun.im/post/css-unit/</id>
        <link href="https://xiayun.im/post/css-unit/">
        </link>
        <updated>2020-04-16T03:27:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常见单位">常见单位</h2>
<ol>
<li>px：像素相对长度单位，相对于显示器屏幕分辨率</li>
<li>em：相对长度单位基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li>
<li>rem：相对单位可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</li>
<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li>
<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li>
<li>vmin：vw和vh中较小的那个。</li>
<li>vmax：vw和vh中较大的那个。</li>
<li>%:百分比</li>
<li>in:寸</li>
<li>cm:厘米</li>
<li>mm:毫米</li>
<li>pt:point，大约1/72寸</li>
<li>pc:pica，大约6pt，1/6寸</li>
<li>ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀)</li>
<li>ch:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)</li>
</ol>
<h2 id="常用">常用</h2>
<p>其中用的最多的单位是<strong>px、em、rem</strong>，这三个的区别是：<br>
px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</p>
<p>em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</p>
<p>对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。</p>
<p>rem中的r意思是root（根源），这也就不难理解了。</p>
<p><mark>em/rem</mark>：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。</p>
<p>关于vh/vw与%区别：<br>
vh和vw大小是相对于视口的高度和宽度，而不是父元素的，%单位是相对于包含它的最近的父元素的高度和宽度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[zsh: no matches found不能指定版本]]></title>
        <id>https://xiayun.im/post/tp-composer/</id>
        <link href="https://xiayun.im/post/tp-composer/">
        </link>
        <updated>2020-04-16T02:55:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<pre><code>composer create-project topthink/think=5.0.* tp50 --prefer-dist
</code></pre>
<p>使用composer安装Thinkphp5.0时发生错误</p>
<pre><code># 提示
zsh: no matches found: think=5.0.*
</code></pre>
<h2 id="解决">解决</h2>
<pre><code># 编辑
nano ~/.zshrc
# 添加
setopt no_nomatch 
# 生效
source ~/.zshrc
</code></pre>
<p>再安装即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回流与重绘]]></title>
        <id>https://xiayun.im/post/reflow-repaint/</id>
        <link href="https://xiayun.im/post/reflow-repaint/">
        </link>
        <updated>2020-04-12T10:24:09.000Z</updated>
        <content type="html"><![CDATA[<p><mark>一句话：回流必将引起重绘，重绘不一定会引起回流。</mark></p>
<p>想要真正的了解回流和重绘，我们首先需要搞清楚浏览器的渲染过程。</p>
<h2 id="浏览器的渲染过程">浏览器的渲染过程</h2>
<p>浏览器渲染过程如下：</p>
<ol>
<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层,在这里先不做展开）</li>
</ol>
<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>
<h3 id="生成渲染树">生成渲染树</h3>
<p>为了构建渲染树，浏览器主要完成了以下工作：</p>
<ol>
<li>从DOM树的根节点开始遍历每个可见节点。</li>
<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>
<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>
</ol>
<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>
<ul>
<li>一些不会渲染输出的节点，比如script、meta、link等。</li>
<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>
</ul>
<p><strong>注意：渲染树只包含可见的节点</strong></p>
<h3 id="回流">回流</h3>
<p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p>会导致回流的操作：</p>
<ol>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
<li>元素尺寸或位置发生改变（包括外边距、内边距、边框大小、高度和宽度等）</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ol>
<p>一些常用且会导致回流的属性和方法：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()</li>
</ul>
<h3 id="重绘">重绘</h3>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<mark>color、background-color、visibility</mark>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<h2 id="性能影响">性能影响</h2>
<p>回流比重绘的代价要更高。</p>
<p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p>
<p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br>
当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p>
<h2 id="如何避免">如何避免</h2>
<h3 id="css">CSS</h3>
<ol>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。</li>
</ol>
<h3 id="javascript">JavaScript</h3>
<ol>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ol>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://juejin.im/post/5c0f104551882509a7683d63#heading-7">你真的了解回流和重绘吗</a></p>
<p><a href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>
]]></content>
    </entry>
</feed>