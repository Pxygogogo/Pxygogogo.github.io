<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pxygogogo.github.io</id>
    <title>小潘的博客</title>
    <updated>2020-03-27T14:05:01.928Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pxygogogo.github.io"/>
    <link rel="self" href="https://pxygogogo.github.io/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://pxygogogo.github.io/images/avatar.png</logo>
    <icon>https://pxygogogo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[属性设置和屏蔽]]></title>
        <id>https://pxygogogo.github.io/post/js-properrty/</id>
        <link href="https://pxygogogo.github.io/post/js-properrty/">
        </link>
        <updated>2020-03-16T01:46:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="属性设置和屏蔽">属性设置和屏蔽</h2>
<ul>
<li>给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。</li>
<li>现在我们完整地讲解一下这个过程：</li>
</ul>
<pre><code>myObject.foo = &quot;bar&quot;;
</code></pre>
<ul>
<li>如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值。</li>
<li>如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作。如果原型链上找不到foo, foo就会被直接添加到myObject上。</li>
<li>然而，如果foo存在于原型链上层，赋值语句myObject.foo = &quot;bar&quot;的行为就会有些不同（而且可能很出人意料）。稍后我们会进行介绍。</li>
<li>如果属性名foo既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性。</li>
<li>屏蔽比我们想象中更加复杂。下面我们分析一下如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = &quot;bar&quot;会出现的三种情况。</li>
</ul>
<ol>
<li>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性（参见第3章）并且没有被标记为只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。</li>
<li>如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在[[Prototype]]链上层存在foo并且它是一个setter（参见第3章），那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。</li>
</ol>
<ul>
<li>大多数开发者都认为如果向[[Prototype]]链上层已经存在的属性（[[Put]]）赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的。如果你希望在第二种和第三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty(..)（参见第3章）来向myObject添加foo。</li>
</ul>
<blockquote>
<p>第二种情况可能是最令人意外的，只读属性会阻止[[Prototype]]链下层隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的foo看作是父类中的属性，它会被myObject继承（复制），这样一来myObject中的foo属性也是只读，所以无法创建。但是一定要注意，实际上并不会发生类似的继承复制（参见第4章和第5章）。这看起来有点奇怪，myObject对象竟然会因为其他对象中有一个只读foo就不能包含foo属性。更奇怪的是，这个限制只存在于=赋值中，使用Object. defineProperty(..)并不会受到影响。</p>
</blockquote>
<blockquote>
<p>来自你不知道的JavaScript上卷</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数柯里化]]></title>
        <id>https://pxygogogo.github.io/post/js-curry/</id>
        <link href="https://pxygogogo.github.io/post/js-curry/">
        </link>
        <updated>2020-03-14T13:01:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数柯里化">函数柯里化</h2>
<p><strong>柯里化（Currying）,维基百科上的解释是，把接受多个参数的函数转换成接受一个单一参数的函数</strong></p>
<p>先看一个简单的例子：</p>
<pre><code>    // 柯里化
    var foo = function(x) {
        return function(y) {
            return x + y
        }
    }
    
    foo(3)(4)       // 7
    
    // 普通方法
    var add = function(x, y) {
        return x + y;
    }
    
    add(3, 4)       //7

</code></pre>
<p>本来应该一次传入两个参数的add函数，柯里化方法，变成每次调用都只用传入一个参数，调用两次后，得到最后的结果。</p>
<p>再看看，一道经典的面试题。</p>
<pre><code>编写一个sum函数，实现如下功能：
console.log(sum(1)(2)(3)) // 6.
</code></pre>
<p>直接套用上面柯里化函数，多加一层return</p>
<pre><code>function sum(a) {
        return function(b) {
            return function(c) {
                return a + b + c;
            }
        }
    }
</code></pre>
<p>当然，柯里化不是为了解决面试题，它是应函数式编程而生，</p>
<h2 id="如何实现">如何实现</h2>
<p>还是看看上面的经典面试题。<br>
如果想实现 <mark>sum(1)(2)(3)(4)(5)...(n)</mark> 就得嵌套 <mark>n-1</mark>个匿名函数，</p>
<p>看起来并不优雅，如果我们预先知道有多少个参数要传入，可以利用递归方法解决</p>
<p>伪代码：</p>
<pre><code>var curry = function(fn) {
    return function() {
        // 假设柯里化的函数叫 curry_fn
        // if &quot;curry_fn接受到的参数数量等于fn接受参数的数量&quot;
        // return &quot;fn的执行结果&quot;
        // else return &quot;一个柯里化函数&quot;
    };
};
</code></pre>
<ul>
<li>递归出口：curry_fn接受到的参数数量等于fn接受参数的数量</li>
<li>重复逻辑：return &quot;一个柯里化函数&quot;</li>
</ul>
<pre><code>var add = function(num1, num2) {
        return num1 + num2;
    }
// 假设 sum 函数调用时，传入参数都是标准的数字
    function curry(add, n) {
       var count = 0, //接受的参数个数
           arr = []; // 存储递归过程的所有参数，用于递归出口计算值
           
       return function reply(arg) {
           arr.push(arg); // 收集递归参数
           
           if ( ++count &gt;= n) {
               //这里也可以在外面定义变量，保存每次计算后结果
               return arr.reduce(function(p, c) {
               // 返回函数执行结果
                   return p = add(p, c);
               }, 0) 
           } else {
           // 返回一个柯里化函数
               return reply;
           }
       }
    }
    var sum = curry(add, 4);
    
    sum(4)(3)(2)(1)  // 10    
    
</code></pre>
<p>根据上述的例子，可以得到，柯里化后的函数如果接受到全部参数则返回函数执行结果，否则返回一个柯里化函数。</p>
<p>这里还有一个小问题，如果调用次数多于约定数量，sum 就会报错，我们就可以设计成类似这样</p>
<pre><code>sum(1)(2)(3)(4)(); // 最后传入空参数，标识调用结束，
</code></pre>
<p>只需要简单修改下curry 函数</p>
<pre><code>function curry(add) {
       var arr = [];
       
       return function reply() {
         var arg = Array.prototype.slice.call(arguments);
         arr = arr.concat(arg);
         
          if (arg.length === 0) { // 递归结束条件，修改为 传入空参数
              return arr.reduce(function(p, c) {
                  return p = add(p, c);
              }, 0)
          } else {
              return reply;
          }
      }
    }
  
  console.log(sum(4)(3)(2)(1)(5)())   // 15
</code></pre>
<h2 id="简洁版实现">简洁版实现</h2>
<p>上面针对具体问题，引入柯里化方法解答，回到如何实现创建柯里化函数的通用方法。<br>
同样先看简单版本的方法，以add方法为例，代码来自《JavaScript高级程序设计》</p>
<pre><code>function curry(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    };
}

function add(num1, num2) {
    return num1 + num2;
}
var curriedAdd = curry(add, 5);

var curriedAdd2 = curry(add, 5, 12);

alert(curriedAdd(3))    // 8
alert(curriedAdd2())    // 17
</code></pre>
<h2 id="加强版实现">加强版实现</h2>
<p>上面add函数，可以换成任何其他函数，经过curry函数处理，都可以转成柯里化函数。<br>
这里在调用curry初始化时，就传入了一个参数，而且返回的函数 curriedAdd , curriedAdd2也没有被柯里化。要想实现更加通用的方法，在柯里化函数真正调用时，再传参数，</p>
<pre><code>function curry(fn) {
     ...
 }

function add(num1, num2) {
    return num1 + num2;
}

var curriedAdd = curry(add);

curriedAdd(3)(4) // 7
</code></pre>
<p>每次调用curry返回的函数，也被柯里化，可以继续传入一个或多个参数进行调用，</p>
<p>跟上面sum(1)(2)(3)(4) 非常类似,利用递归就可以实现。 关键是递归的出口，这里不能是传入一个空参数的调用， 而是原函数定义时，参数的总个数，柯里化函数调用时，满足了原函数的总个数，就返回计算结果，否则，继续返回柯里化函数。</p>
<p>原函数的入参总个数，可以利用length 属性获得</p>
<pre><code>function add(num1, num2) {
    return num1 + num2;
}

add.length // 
</code></pre>
<p>结合上面的代码，</p>
<pre><code>var curry = function(f) {
      var len = f.length;
      
        return function t() {
          var innerLength = arguments.length,
            args = Array.prototype.slice.call(arguments);
            
          if (innerLength &gt;= len) {   // 递归出口，f.length
             return f.apply(undefined, args)
          } else {
            return function() {
              var innerArgs = Array.prototype.slice.call(arguments),
                allArgs = args.concat(innerArgs);
                
              return t.apply(undefined, allArgs)
            }
          }
        }
    }
    
   // 测试一下
  function add(num1, num2) {
    return num1 + num2;
  }

   var curriedAdd = curry(add);
   add(2)(3);     //5

  // 一个参数
  function identity(value) {
     return value;
 }

   var curriedIdentify = curry(identify);
   curriedIdentify(4) // 4
</code></pre>
<p>到此，柯里化通用函数可以满足大部分需求了。</p>
<p><strong>在使用 apply 递归调用的时候，默认传入 undefined, 在其它场景下，可能需要传入 context， 绑定指定环境</strong></p>
<p>实际开发，推荐使用 <a href="https://lodash.com/docs/4.17.15#curry">lodash.curry</a> , 具体实现，可以参考下<a href="https://github.com/lodash/lodash/blob/4.3.0-npm-packages/lodash.curry/index.js">curry源码</a></p>
<h2 id="使用场景">使用场景</h2>
<p>讲了这么多curry函数的不同实现方法，那么实现了通用方法后，在那些场景下可以使用，或者说使用柯里化函数是否可以真实的提高代码质量，下面总结一下使用场景</p>
<ol>
<li>参数复用</li>
</ol>
<pre><code>// 正常正则验证字符串 reg.test(txt)

// 函数封装后
function check(reg, txt) {
    return reg.test(txt)
}

check(/\d+/g, 'test')       //false
check(/[a-z]+/g, 'test')    //true

// Currying后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}

var hasNumber = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasNumber('test1')      // true
hasNumber('testtest')   // false
hasLetter('21212')      // false
</code></pre>
<p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。</p>
<ol start="2">
<li>提前确认</li>
</ol>
<pre><code>var on = function(element, event, handler) {
    if (document.addEventListener) {
        if (element &amp;&amp; event &amp;&amp; handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element &amp;&amp; event &amp;&amp; handler) {
            element.attachEvent('on' + event, handler);
        }
    }
}

var on = (function() {
    if (document.addEventListener) {
        return function(element, event, handler) {
            if (element &amp;&amp; event &amp;&amp; handler) {
                element.addEventListener(event, handler, false);
            }
        };
    } else {
        return function(element, event, handler) {
            if (element &amp;&amp; event &amp;&amp; handler) {
                element.attachEvent('on' + event, handler);
            }
        };
    }
})();

//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了
var on = function(isSupport, element, event, handler) {
    isSupport = isSupport || document.addEventListener;
    if (isSupport) {
        return element.addEventListener(event, handler, false);
    } else {
        return element.attachEvent('on' + event, handler);
    }
}
</code></pre>
<p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。</p>
<ol start="3">
<li>延迟运行</li>
</ol>
<pre><code>Function.prototype.bind = function (context) {
    var _this = this
    var args = Array.prototype.slice.call(arguments, 1)
 
    return function() {
        return _this.apply(context, args)
    }
}
</code></pre>
<p>像我们js中经常使用的bind，实现的机制就是Currying.</p>
<ol start="4">
<li>函数式编程中，作为compose, functor, monad 等实现的基础</li>
</ol>
<p>有人说柯里化是应函数式编程而生，它在里面出现的概率就非常大了，在JS 函数式编程指南中，开篇就介绍了柯里化的重要性。</p>
<h2 id="柯里化的性能">柯里化的性能</h2>
<p>从上面实现部分的代码中，可以看到，使用柯里化函数，离不开闭包， arguments， 递归。</p>
<ul>
<li>闭包，函数中的变量都保存在内存中，内存消耗大，有可能导致内存泄漏。</li>
<li>递归，效率非常差，</li>
<li>arguments, 变量存取慢，访问性很差,存取arguments对象通常要比存取命名参数要慢一点</li>
<li>使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点</li>
</ul>
<h2 id="参考资料">参考资料：</h2>
<ul>
<li>https://www.jianshu.com/p/2975c25e4d71</li>
<li>https://segmentfault.com/a/1190000018265172</li>
<li>https://segmentfault.com/a/1190000018203637</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器中堆栈内存的底层处理]]></title>
        <id>https://pxygogogo.github.io/post/stack-heap-in-browser/</id>
        <link href="https://pxygogogo.github.io/post/stack-heap-in-browser/">
        </link>
        <updated>2020-03-13T05:31:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器执行代码需要经历什么">浏览器执行代码需要经历什么</h2>
<h3 id="编译">编译</h3>
<ul>
<li>词法解析：这个过程会将由字符组成的字符串分解成有意义的代码块（词法单元）</li>
<li>语法分析：这个过程将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法的树（抽象语法树 =&gt; <mark>AST</mark>）</li>
<li>代码生成：将<mark>AST</mark>转换为可执行代码的过程被称为代码生成</li>
</ul>
<h3 id="引擎编译执行代码">引擎编译执行代码</h3>
<p>然后将构建出的代码交给引擎（V8），这个时候可能会遇到<mark>变量提升、作用域和作用域链/闭包、变量对象、堆栈内存、GO/VO/AO/EC/ECStack</mark>...</p>
<blockquote>
<h4 id="几个术语说明">几个术语说明：</h4>
<p><mark>ECstack</mark>：执行上下文环境栈</p>
<p><mark>EC</mark>：执行上下文 分为全局执行上下文 <mark>EC(G)</mark> 和函数执行上下文(<mark>EC(...)</mark>)</p>
<p><mark>GO(Global Object)</mark>：全局对象浏览器端，会把GO赋值给window</p>
<p><mark>VO(Varible Object)</mark>：变量对象，存储当前上下文中的变量</p>
<p><mark>AO(Activation Object)</mark>：活动对象，在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色</p>
</blockquote>
<p>引擎在编译执行代码的过程中，首先会创建一个执行栈，也就是栈内存（ECStack =&gt; 执行环境栈），然后执行代码</p>
<p>在代码执行会创建EC(执行上下文)，执行上下文分为全局执行上下文（EC(G)）和函数执行上下文（EC(...)）,其中函数的执行上下文是私有的。</p>
<p>创建执行上下文的过程中，可能会创建：GO、VO、AO<br>
然后将进栈执行，创建好的上下文将压缩到栈中执行，执行后一些没用的上下文将出栈，有用的上下文会压缩到栈底（闭包）。栈底永远是全局执行上下文，栈顶则永远是当前执行上下文</p>
<h3 id="变量赋值的三步操作">变量赋值的三步操作</h3>
<ul>
<li>
<p>第一步，创建变量，这个过程叫做声明(declare)。</p>
</li>
<li>
<p>第二步，创建值。基本类型值会直接在栈中创建和存储；由于引用类型值是复杂的结构，所以需开辟一个存储对象中键值对（存储函数中代码）的内存空间，这个内存就是堆内存，所有的堆内存都有可被后续查找的16进制地址，后续关联赋值时，是把堆内存地址给予变量操作。</p>
</li>
<li>
<p>最后一步，将变量和值关联，这个过程叫做定义(defined)。这里，如果值只经过了声明，而没有进行赋值操作，这个值就是未定义(undefined)。</p>
</li>
</ul>
<blockquote>
<p>注：简单理解为</p>
<ul>
<li>栈内存存放执行代码和基本类型的值</li>
<li>堆内存存放复杂结构，如对象</li>
</ul>
</blockquote>
<p>例题：</p>
<pre><code>// 例一
let a = 12;
let b = a;
b = 13;
console.log(a);

// 例二
let a = {n:12};
let b = a;
b['n'] = 13;
console.log(a.n);

// 例三
let a = {n:12};
let b = a;
b = {n:13};
console.log(a.n);

</code></pre>
<p>例一<br>
<img src="https://s1.ax1x.com/2020/03/13/8nyz8A.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a值为12</p>
<p>例二<br>
<img src="https://s1.ax1x.com/2020/03/13/8n6AUg.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a.n为13</p>
<p>例三<br>
<img src="https://s1.ax1x.com/2020/03/13/8ncQSA.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a.n的值为12</p>
<h3 id="真实面试题">真实面试题</h3>
<ul>
<li>题一</li>
</ul>
<pre><code>let a = {
    n: 10
};
let b = a;
b.m = b = {
    n: 20
};
console.log(a);
console.log(b);

</code></pre>
<ul>
<li>解一<br>
<img src="https://s1.ax1x.com/2020/03/13/8n2zo8.jpg" alt="image" loading="lazy"></li>
</ul>
<p>所以最终输出的a为{n: 10, m: {n: 20}};b为{n: 20}</p>
<ul>
<li>题二</li>
</ul>
<pre><code>let x = [12, 23];
function fn(y) {
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y);
}
fn(x);
console.log(x);

</code></pre>
<ul>
<li>解二<br>
<img src="https://s1.ax1x.com/2020/03/13/8nvnzR.jpg" alt="image" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/03/13/8nv3dO.jpg" alt="image" loading="lazy"></figure>
<p>答案是：[100, 200] [100, 23]</p>
<h3 id="思考题">思考题</h3>
<ul>
<li>思考题一</li>
</ul>
<pre><code>var x = 10;
~ function (x) {
    console.log(x);
    x = x || 20 &amp;&amp; 30 || 40;
    console.log(x);
}();
console.log(x);
</code></pre>
<ul>
<li>思考题二</li>
</ul>
<pre><code>let x = [1, 2],
    y = [3, 4];
~ function (x) {
    x.push('A');
    x = x.slice(0);
    x.push('B');
    x = y;
    x.push('C');
    console.log(x, y);
}(x);
console.log(x, y);
</code></pre>
<ul>
<li>思考题一答案</li>
</ul>
<p><mark>undefined 30 10</mark></p>
<ul>
<li>思考题二答案</li>
</ul>
<p><mark>[3, 4, 'C'] [3, 4, 'C'] [1, 2, 'A'] [3, 4, 'C']</mark></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mongoose得到的对象不能增加属性解决方法（两种）]]></title>
        <id>https://pxygogogo.github.io/post/mongoose-query/</id>
        <link href="https://pxygogogo.github.io/post/mongoose-query/">
        </link>
        <updated>2020-03-11T04:39:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实例">实例</h2>
<ul>
<li>Notice模型文件如下：</li>
</ul>
<pre><code>const mongoose = require('mongoose');

const schema = mongoose.Schema({
    userId:{type:String},
    time: {type:String},
    medicines: {type:Array},
    noticePerson:{type:String},
    acrtTime:{type:String},
});

module.exports = mongoose.model('Notice',schema);
</code></pre>
<ul>
<li>路由响应如下：</li>
</ul>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            result.email = email; //无法生效
            res.send(result);
        }
    });
</code></pre>
<ul>
<li>问题描述：<br>
希望向得到的result数据中添加一个email属性，但直接添加无法成功</li>
</ul>
<hr>
<h2 id="原因">原因</h2>
<ul>
<li>因为Mongoose是個ODM (Object Document Mapper)，类似于操作关系型数据库使用的ORM(Object Relational Mapper)，我们使用Mongoose取到的数据的结构是要依赖于我们定义的schema结构的。增加的email属性在schema中没有定义，所以我们在取到的结果中增加email属性是无效的</li>
</ul>
<hr>
<h2 id="解决办法">解决办法</h2>
<ul>
<li>解决办法一</li>
</ul>
<p><mark>在schema中直接增加需要补充的属性</mark></p>
<p>在本例中即向Notice模型中添加一个email字段</p>
<ul>
<li>解决办法二</li>
</ul>
<p><mark>把查询到的结果clone一个对象，然后在新对象中补充属性</mark></p>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            const data = {
                ...result._doc,
                email,
            };
            res.send(data);
        }
    });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssh 免密码快速登录（MacOs）]]></title>
        <id>https://pxygogogo.github.io/post/ssh-login/</id>
        <link href="https://pxygogogo.github.io/post/ssh-login/">
        </link>
        <updated>2020-03-05T11:47:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建秘钥文件">1.创建秘钥文件</h2>
<ul>
<li>打开终端，执行 ssh-keygen 命令创建密钥对：</li>
</ul>
<blockquote>
<pre><code class="language-bash">ssh-keygen -t rsa -C 'your email@domain.com'
-t 指定密钥类型，默认即 rsa ，可以省略
-C 设置注释文字，比如你的邮箱，可以省略
</code></pre>
</blockquote>
<ul>
<li>生成过程中会提示输入密码两次，如果不想在使用公钥的时候输入密码，可以回车跳过；<br>
密钥默认保存位置在 <code>~/.ssh</code> 目录下，打开后会看到私钥文件 <code>id_rsa</code> 和公钥文件 <code>id_rsa.pub</code>；</li>
</ul>
<h2 id="2复制公钥至服务器">2.复制公钥至服务器</h2>
<ul>
<li>
<p>通过宝塔面板直接将<code>~/.ssh/id_rsa.pub</code>配置到服务器的<code>~/.ssh/authorized_keys</code>文件中</p>
</li>
<li>
<p>使用 scp 命令将本地的公钥文件 <code>id_rsa.pub</code> 复制到需要连接的Linux服务器：</p>
<pre><code class="language-bash">scp ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-bash">scp -P &lt;端口号&gt; ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>把公钥追加到服务器ssh认证文件中:</p>
<pre><code class="language-bash">cat /home/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
</li>
<li>
<p>这时候在本地终端中使用用户名和ip登录就不需要密码了：</p>
<pre><code class="language-xml">ssh &lt;用户名&gt;@&lt;ip&gt;
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-xml">ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;ip地址&gt;
</code></pre>
</li>
</ul>
<h2 id="3配置快捷登录">3.配置快捷登录</h2>
<ul>
<li>在本地 <code>~/.ssh/config</code> 配置文件中添加ssh服务器信息（可多个），格式：</li>
</ul>
<blockquote>
<pre><code class="language-ruby">Host            alias            #自定义别名
HostName        hostname         #替换为你的ssh服务器ip或domain
Port            port             #ssh服务器端口，默认为22
User            user             #ssh服务器用户名
IdentityFile    ~/.ssh/id_rsa    #第一个步骤生成的公钥文件对应的私钥文件
</code></pre>
</blockquote>
<ul>
<li>配置成功后，即可直接通过<code>ssh alias</code>登录</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组扁平化]]></title>
        <id>https://pxygogogo.github.io/post/js-flatten/</id>
        <link href="https://pxygogogo.github.io/post/js-flatten/">
        </link>
        <updated>2020-02-14T07:22:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="扁平化">扁平化</h2>
<p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。</p>
<p>举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：</p>
<pre><code class="language-js">var arr = [1, [2, [3, 4]]];
console.log(flatten(arr)) // [1, 2, 3, 4]
</code></pre>
<p>知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了</p>
<h2 id="递归">递归</h2>
<p>我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法：</p>
<pre><code class="language-js">// 方法 1
var arr = [1, [2, [3, 4]]];

function flatten(arr) {
    var result = [];
    for (var i = 0,  i &lt; arr.length; i++) {
        if (Array.isArray(arr[i])) {
            result = result.concat(flatten(arr[i]))
        }
        else {
            result.push(arr[i])
        }
    }
    return result;
}


console.log(flatten(arr))
</code></pre>
<h2 id="tostring">toString</h2>
<p>如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：</p>
<pre><code class="language-js">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;
</code></pre>
<p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？</p>
<pre><code class="language-js">// 方法2
var arr = [1, [2, [3, 4]]];

function flatten(arr) {
    return arr.toString().split(',').map(function(item){
        return +item
    })
}

console.log(flatten(arr))
</code></pre>
<p>然而这种方法使用的场景却非常有限，如果数组是 [1, '1', 2, '2'] 的话，这种方法就会产生错误的结果。</p>
<h2 id="reduce">reduce</h2>
<p>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码：</p>
<pre><code class="language-js">function flatten(arr){
    return arr.reduce((acc,cur)=&gt;{
        return acc.concat(Array.isArray(cur) ? flatten(cur) : cur);
    },[])
}
</code></pre>
<pre><code class="language-js">//简化
const flatten =  (arr) =&gt; arr.reduce((acc,cur)=&gt; acc.concat(Array.isArray(cur) ? flatten(cur) : cur),[]);
</code></pre>
<h2 id="运用es6-扩展运算符">运用es6 扩展运算符</h2>
<pre><code class="language-js">const flattenDeep = (arr) =&gt; Array.isArray(arr) ? arr.reduce( (a, b) =&gt; [...a, ...flattenDeep(b)] , []) : [arr];

flattenDeep([1, [[2], [3, [4]], 5]])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序页面跳转的一系列注意点]]></title>
        <id>https://pxygogogo.github.io/post/nagivation-problems/</id>
        <link href="https://pxygogogo.github.io/post/nagivation-problems/">
        </link>
        <updated>2020-02-13T11:34:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>showModel 回调无法跳转除TabBar之外的页面</p>
<ul>
<li>回调中只能使用switchTab进行跳转</li>
</ul>
</li>
<li>
<p>switchTab跳转后页面不刷新</p>
<ul>
<li>
<p>法一：switchTab成功跳转后调用success,此时可以拿到跳转后页面的page对象,从而调用页面onLoad方法重载页面</p>
<pre><code class="language-javascript">wx.switchTab({
    url: '/pages/index/index',
    success: function(e) {
        let page = getCurrentPages().pop();
        if (page == undefined || page == null) return;
        page.onLoad();
    }
})
</code></pre>
</li>
<li>
<p>法二：当switchTab点击过的时候，只有第一次加载数据，第二次点击的时候是不刷新数据的，这个时候只要在需要每次点击都需要刷新数据的TabBar页的js里加上onShow的方法即可</p>
<pre><code class="language-javascript"> onShow:function(e){
       this.onLoad();
 },
</code></pre>
</li>
</ul>
</li>
<li>
<p>TabBar页面只能使用switchTab跳转</p>
<ul>
<li>文档里有写，使用时需注意</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js数组去重]]></title>
        <id>https://pxygogogo.github.io/post/js-unique-arr/</id>
        <link href="https://pxygogogo.github.io/post/js-unique-arr/">
        </link>
        <updated>2020-02-13T02:26:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-利用es6-set去重es6中最常用">一、利用ES6 Set去重（ES6中最常用）</h2>
<pre><code class="language-js">function unique (arr) {
  return Array.from(new Set(arr))
}
</code></pre>
<p>甚至可以再简化下：</p>
<pre><code class="language-js">function unique(array) {
    return [...new Set(array)];
}
</code></pre>
<p>还可以再简化下：</p>
<pre><code class="language-js">var unique = (a) =&gt; [...new Set(a)]
</code></pre>
<p>此外，如果用 Map 的话：</p>
<pre><code class="language-js">function unique (arr) {
    const seen = new Map()
    return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))
}
</code></pre>
<h2 id="二-利用for嵌套for然后splice去重es5中最常用">二、利用for嵌套for，然后splice去重（ES5中最常用）</h2>
<pre><code class="language-js">function unique(arr){
    for(let i = 0 ; i &lt; arr.length ; i++){
        for(let j = i+1 ; j &lt; arr.length ; j++){
            if(arr[i] === arr[j]){
                arr.splice(j,1);
                j--;
            }
        }
    }
    return arr;
}
</code></pre>
<p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</p>
<h2 id="三-利用indexof去重">三、利用indexOf去重</h2>
<pre><code class="language-js">function unique(arr){
    if(!Array.isArray(arr)){
        throw Error('wrong type,Array required')
    }
    let res = [];
    for (let i = 0; i &lt; arr.length; i++) {
        if(res.indexOf(arr[i])===-1){
            res.push(arr[i])
        }
    }
    return res;
}
</code></pre>
<p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p>
<h2 id="四-利用sort">四、利用sort()</h2>
<pre><code class="language-js">function unique(arr){
    if(!Array.isArray(arr)){
        throw Error('wrong type,Array required')
    }
    arr = arr.sort();
    let res = [arr[0]];
    for (let i = 1; i &lt; arr.length ; i++) {
        if(arr[i]!==arr[i-1]){
            res.push(arr[i])
        }
    }
    return res;
}
</code></pre>
<p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p>
<h2 id="五-object-键值对">五、Object 键值对</h2>
<p>这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。示例代码如下：</p>
<pre><code class="language-js">var array = [1, 2, 1, 1, '1'];

function unique(array) {
    var obj = {};
    return array.filter(function(item, index, array){
        return obj.hasOwnProperty(item) ? false : (obj[item] = true)
    })
}

console.log(unique(array)); // [1, 2]
</code></pre>
<p>我们可以发现，是有问题的，因为 1 和 '1' 是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所以我们可以使用 <code>typeof item + item</code> 拼成字符串作为 key 值来避免这个问题：</p>
<pre><code class="language-js">var array = [1, 2, 1, 1, '1'];

function unique(array) {
    var obj = {};
    return array.filter(function(item, index, array){
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
}

console.log(unique(array)); // [1, 2, &quot;1&quot;]
</code></pre>
<p>然而，即便如此，我们依然无法正确区分出两个对象，比如 {value: 1} 和 {value: 2}，因为 <code>typeof item + item</code> 的结果都会是 <code>object[object Object]</code>，不过我们可以使用 JSON.stringify 将对象序列化：</p>
<pre><code class="language-js">var array = [{value: 1}, {value: 1}, {value: 2}];

function unique(array) {
    var obj = {};
    return array.filter(function(item, index, array){
        console.log(typeof item + JSON.stringify(item))
        return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true)
    })
}

console.log(unique(array)); // [{value: 1}, {value: 2}]
</code></pre>
<h2 id="六-filter">六、filter</h2>
<p>ES5 提供了 filter 方法，我们可以用来简化外层循环：</p>
<p>比如使用 indexOf 的方法：</p>
<pre><code class="language-js">function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[节流]]></title>
        <id>https://pxygogogo.github.io/post/js-throttle/</id>
        <link href="https://pxygogogo.github.io/post/js-throttle/">
        </link>
        <updated>2020-02-12T08:03:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="节流">节流</h2>
<p>节流的原理很简单：</p>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。<br>
我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h2 id="使用时间戳">使用时间戳</h2>
<p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<pre><code class="language-js">// 第一版
function throttle(func, wait) {
    var context, args;
    var previous = 0;
    return function() {
        var now = +new Date();
        context = this;
        args = arguments;
        if (now - previous &gt; wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
</code></pre>
<h2 id="使用定时器">使用定时器</h2>
<p>接下来，我们讲讲第二种实现方式，使用定时器。</p>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<pre><code>// 第二版
function throttle(func, wait) {
    var timeout;
    var previous = 0;

    return function() {
        context = this;
        args = arguments;
        if (!timeout) {
            timeout = setTimeout(function(){
                timeout = null;
                func.apply(context, args)
            }, wait)
        }

    }
}
</code></pre>
<p>所以比较两个方法：</p>
<ol>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ol>
<h2 id="双剑合璧">双剑合璧</h2>
<p>那我们想要一个什么样的呢？</p>
<p>有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！</p>
<p>所以我们综合两者的优势，然后双剑合璧，写一版代码：</p>
<pre><code class="language-js">// 第三版
function throttle(func, wait) {
    var timeout, context, args, result;
    var previous = 0;

    var later = function() {
        previous = +new Date();
        timeout = null;
        func.apply(context, args)
    };

    var throttled = function() {
        var now = +new Date();
        //下次触发 func 剩余的时间
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
         // 如果没有剩余的时间了或者你改了系统时间
        if (remaining &lt;= 0 || remaining &gt; wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
        } else if (!timeout) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;
}
</code></pre>
<h2 id="优化">优化</h2>
<p>但是我有时也希望无头有尾，或者有头无尾，这个咋办？</p>
<p>那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p>
<p>leading：false 表示禁用第一次执行<br>
trailing: false 表示禁用停止触发的回调</p>
<p>我们来改一下代码：</p>
<pre><code class="language-js">// 第四版
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        func.apply(context, args);
        if (!timeout) context = args = null;
    };

    var throttled = function() {
        var now = new Date().getTime();
        if (!previous &amp;&amp; options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining &lt;= 0 || remaining &gt; wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout &amp;&amp; options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;
}
</code></pre>
<h2 id="取消">取消</h2>
<p>在 debounce 的实现中，我们加了一个 cancel 方法，throttle 我们也加个 cancel 方法：</p>
<pre><code class="language-js">// 第五版 非完整代码
...
throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = null;
}
...
</code></pre>
<h2 id="注意">注意</h2>
<p>我们要注意 underscore 的实现中有这样一个问题：</p>
<p>那就是 <code>leading：false</code> 和 <code>trailing: false</code> 不能同时设置。</p>
<p>如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了，所以，这个 throttle 只有三种用法：</p>
<pre><code class="language-js">container.onmousemove = throttle(getUserAction, 1000);
container.onmousemove = throttle(getUserAction, 1000, {
    leading: false
});
container.onmousemove = throttle(getUserAction, 1000, {
    trailing: false
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防抖]]></title>
        <id>https://pxygogogo.github.io/post/js-debounce/</id>
        <link href="https://pxygogogo.github.io/post/js-debounce/">
        </link>
        <updated>2020-02-12T02:48:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在前端开发中会遇到一些频繁的事件触发，比如：</p>
<ol>
<li>window 的 resize、scroll</li>
<li>mousedown、mousemove</li>
<li>keyup、keydown<br>
......</li>
</ol>
<h2 id="引例">引例</h2>
<p>index.html文件如下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge, chrome=1&quot;&gt;
    &lt;title&gt;debounce&lt;/title&gt;
    &lt;style&gt;
        #container{
            width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var count = 1;
        var container = document.getElementById('container');
    
        function getUserAction() {
            container.innerHTML = count++;
        };
    
        container.onmousemove = getUserAction;
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>效果如下：<br>
<img src="https://i.loli.net/2020/03/25/U3I84RAEVWqksZN.gif" alt="演示效果" loading="lazy"></p>
<p>从左边滑到右边就触发了 129 次 getUserAction 函数！</p>
<p>因为这个例子很简单，所以浏览器完全反应的过来，可是如果是复杂的回调函数或是 ajax 请求呢？假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。</p>
<p>为了解决这个问题，一般有两种解决方案：</p>
<ol>
<li>debounce 防抖</li>
<li>throttle 节流</li>
</ol>
<p>下面重点介绍防抖的实现。</p>
<h2 id="防抖">防抖</h2>
<p>防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。</p>
<p>这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。</p>
<p>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行!</p>
<h2 id="第一版">第一版</h2>
<p>根据这段表述，我们可以轻松写出第一版的代码：</p>
<pre><code class="language-js">//第一版
function debounce(func,wait){
    var timeout;
    return function(){
        clearTimeout(timeout);
        timeout = setTimeOut(func,wait)
    }
}
</code></pre>
<p>如果我们要使用它，以最一开始的例子为例：</p>
<pre><code class="language-js">container.onmousemove = debounce(getUserAction, 1000);
</code></pre>
<p>现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。</p>
<h2 id="this">this</h2>
<p>如果我们在 <code>getUserAction</code> 函数中 <code>console.log(this)</code>，在不使用 <code>debounce</code> 函数的时候，<code>this</code> 的值为：</p>
<pre><code class="language-html">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
</code></pre>
<p>但是如果使用我们的 debounce 函数，this 就会指向 Window 对象！</p>
<p>所以我们需要将 this 指向正确的对象。</p>
<p>我们修改下代码：</p>
<pre><code class="language-js">//第二版
function debounce(func,wait){
    var timeout;
    return function(){
        var context = this;
        clearTimeout(timeout);
        timeout = setTimeOut(function(){
            func.apply(context)
        },wait)
    }
}
</code></pre>
<p>现在 this 已经可以正确指向了。让我们看下个问题：</p>
<h2 id="event-对象">event 对象</h2>
<p>JavaScript 在事件处理函数中会提供事件对象 event，我们修改下 getUserAction 函数：</p>
<pre><code class="language-js">function getUserAction(e) {
    console.log(e);
    container.innerHTML = count++;
};
</code></pre>
<p>如果我们不使用 debouce 函数，这里会打印 MouseEvent 对象</p>
<p>但是在我们实现的 debounce 函数中，却只会打印 undefined!</p>
<p>所以我们再修改一下代码：</p>
<pre><code class="language-js">//第三版
function debounce(func.wait){
    var timeout;
    return function(){
        var context = this;
        vat args = arguments;
        clearTimeOut(timeout);
        timeout = setTimeOut(function(){
            func.apply(context,args)
        },wait)
    }
}
</code></pre>
<p>到此为止，我们修复了两个小问题：</p>
<ol>
<li>this 指向</li>
<li>event 对象</li>
</ol>
<h2 id="立刻执行">立刻执行</h2>
<p>这个时候，代码已经很是完善了，但是为了让这个函数更加完善，我们接下来思考一个新的需求。</p>
<p>这个需求就是：</p>
<p>我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。</p>
<p>想想这个需求也是很有道理的嘛，那我们加个 immediate 参数判断是否是立刻执行。</p>
<pre><code class="language-js">// 第四版
function debounce(func, wait, immediate) {

    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
</code></pre>
<h2 id="返回值">返回值</h2>
<p>此时注意一点，就是 getUserAction 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果。</p>
<pre><code class="language-js">// 第五版
function debounce(func, wait, immediate) {

    var timeout, result;

    return function () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) result = func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>