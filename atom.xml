<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-05-11T14:37:36.671Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[package.json和package-lock.json的区别]]></title>
        <id>https://xiayun.im/post/package.json-package.lock.json/</id>
        <link href="https://xiayun.im/post/package.json-package.lock.json/">
        </link>
        <updated>2020-05-11T14:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>package.json:</p>
<p>主要用来定义项目中需要依赖的包</p>
<p>package-lock.json：</p>
<p>根据官方文档，package-lock.json是生成的系统当前安装的库的具体来源和版本号，锁定版本。在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</p>
<p>当你执行npm install的时候， node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，node是从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。</p>
<p>当package.json与package-lock.json都不存在，执行&quot;npm install&quot;时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件，此时，你可以通过&quot;npm init --yes&quot;来生成package.json文件</p>
<p>参考：https://blog.csdn.net/u013992330/java/article/details/81110018</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css踩坑之z-index]]></title>
        <id>https://xiayun.im/post/css-z-index/</id>
        <link href="https://xiayun.im/post/css-z-index/">
        </link>
        <updated>2020-05-11T14:36:28.000Z</updated>
        <content type="html"><![CDATA[<p>z-index 属性指定一个元素的堆叠顺序<br>
拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面</p>
<p><mark>注意！！！： z-index 只适用于已定位的元素(position:absolute, position:relative, or position:fixed)</mark></p>
<p>所以z-index是一种依赖属性，依赖position属性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux和Flux]]></title>
        <id>https://xiayun.im/post/redux-and-flux/</id>
        <link href="https://xiayun.im/post/redux-and-flux/">
        </link>
        <updated>2020-05-11T14:35:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="flux">Flux</h2>
<h3 id="flux-优点">Flux 优点</h3>
<ul>
<li><strong>最重要的就是“<mark>单向数据流</mark>”的管理方式</strong>。在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</li>
</ul>
<p>解决的MVC的问题:</p>
<blockquote>
<p>MVC最大的问题就是无法禁绝View和Model之间的直接对话，对应于MVC中View就是Flux中的View，对应于MVC中的Model的就是Flux中的Store，在Flux中，Store只有get方法，没有set方法，根本可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action对象给Dispatcher</p>
</blockquote>
<h3 id="flux-不足">Flux 不足</h3>
<ol>
<li>Store之间依赖关系</li>
<li>难以进行服务器端渲染</li>
<li>Store混杂了逻辑和状态</li>
</ol>
<h2 id="redux">Redux</h2>
<p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p>
<p>Flux的基本原则是“单向数据流”,</p>
<p>Redux在此基础上强调三个基本原则：</p>
<ul>
<li>唯一数据源（Single Source of Truth）；</li>
</ul>
<p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。这个唯一Store上的状态，是一个树形的对象，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题</p>
<ul>
<li>保持状态只读（State is read-only）；</li>
</ul>
<p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p>
<ul>
<li>数据改变只能通过纯函数完成（Changes are made with pure functions）。</li>
</ul>
<p>这里所说的纯函数就是Reducer, Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。就以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer, reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次参数reducer，通过reducer函数完成规约所有元素的功能.</p>
<blockquote>
<p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的UI=render(state)思想完全契合</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux理解]]></title>
        <id>https://xiayun.im/post/redux-learning/</id>
        <link href="https://xiayun.im/post/redux-learning/">
        </link>
        <updated>2020-05-10T03:57:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/05/09/YMT4Hg.jpg" alt="redux工作流程" loading="lazy"></figure>
<ol>
<li>一个比喻：</li>
</ol>
<ul>
<li>component --- 读者</li>
<li>store --- 图书馆</li>
<li>reducer --- 图书管理员</li>
<li>action --- 读者的动作</li>
</ul>
<ol start="2">
<li>流程理解</li>
</ol>
<ul>
<li>所有component的数据状态均来自统一的store中</li>
<li>如果需要更新store中的数据，需要在对应的事件中定义一个action，action就是一个对象，这个对象一般有两个属性，第一个是对action的描述，第二个是要改变的值</li>
<li>action会通过dispatch方法将type和value通过store的自动推送策略直接传递给reducer（虚线的作用）</li>
<li>reducer的两个参数</li>
</ul>
<blockquote>
<p>state：指的是原始仓库里的状态</p>
<p>action: 指的是action新传递的状态</p>
</blockquote>
<ul>
<li>reducer中不能直接修改state，需要深拷贝一个state对象，然后在新的state对象上操作，并最终返回新的state</li>
</ul>
<ol start="3">
<li>注意点</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux小技巧]]></title>
        <id>https://xiayun.im/post/redux-tips/</id>
        <link href="https://xiayun.im/post/redux-tips/">
        </link>
        <updated>2020-05-10T03:56:27.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>把Action Types单独写入一个文件<br>
单独出来的原因：</li>
</ol>
<ul>
<li>这些Types如果不统一管理，不利于大型项目的服用，设置会长生冗余代码。</li>
<li>因为Action里的Type，一定要和Reducer里的type一一对应在，所以这部分代码或字母写错后，浏览器里并没有明确的报错，这给调试带来了极大的困难。</li>
</ul>
<p>例：</p>
<pre><code class="language-js">// 导出 目录：src/store/actionTypes.js
export const  CHANGE_INPUT = 'changeInput'
export const  ADD_ITEM = 'addItem'
export const  DELETE_ITEM = 'deleteItem'

// 引入
import { CHANGE_INPUT , ADD_ITEM , DELETE_ITEM } from './store/actionTypes'
</code></pre>
<ol start="2">
<li>把所有的Redux Action放到一个文件里进行管理</li>
</ol>
<p>例：</p>
<pre><code>// 目录：src/store/actionCreators.js
import {CHANGE_INPUT}  from './actionTypes'

export const changeInputAction = (value)=&gt;({
    type:CHANGE_INPUT,
    value
})
// 引入
import {changeInputAction} from './store/actionCreatores'
changeInputValue(e){
    const action = changeInputAction(e.target.value)
    store.dispatch(action)
}
</code></pre>
<ol start="3">
<li>redux三个小坑</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
<ol start="4">
<li>可选的好方式</li>
</ol>
<ul>
<li>UI和业务逻辑分离</li>
<li>无状s态组件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ThinkPHP5+宝塔+nginx环境下访问路由出现404问题]]></title>
        <id>https://xiayun.im/post/tp5-nigix-404/</id>
        <link href="https://xiayun.im/post/tp5-nigix-404/">
        </link>
        <updated>2020-05-01T14:20:28.000Z</updated>
        <content type="html"><![CDATA[<p>在网站伪静态下添加</p>
<pre><code>location / {
    if (!-e $request_filename){
	      rewrite ^(.*)$ /index.php?s=$1 last; break;
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker创建mysql数据库并导入sql文件]]></title>
        <id>https://xiayun.im/post/docker-mysql/</id>
        <link href="https://xiayun.im/post/docker-mysql/">
        </link>
        <updated>2020-04-23T14:08:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1安装mysql">1.安装mysql</h2>
<h3 id="11-拉取镜像以5726为例">1.1 拉取镜像（以5.7.26为例）</h3>
<pre><code>docker pull mysql:5.7.26
</code></pre>
<h3 id="12-运行容器">1.2 运行容器</h3>
<pre><code>docker run -itd --name mysql-test -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre>
<p>参数说明：</p>
<ul>
<li>-p 3307:3306 ：映射容器服务的 3307 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3307 访问到 MySQL 的服务。</li>
<li>MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。</li>
</ul>
<h2 id="2docker操作mysql创建数据库">2.docker操作mysql创建数据库</h2>
<h3 id="21-确定linux中的docker容器mysql正常运行">2.1 确定linux中的docker容器（mysql）正常运行</h3>
<h3 id="22-执行命令docker-exec-it-容器名称-bash-进入容器bash-即进入到mysql容器中">2.2 执行命令：“docker exec -it 容器名称 bash” 进入容器bash-即进入到mysql容器中</h3>
<h3 id="23-登录mysqlmysql-uroot-p-使用root账号登录mysql">2.3 登录mysql：mysql -uroot -p      使用root账号登录mysql</h3>
<h3 id="24-页面提示输入密码数据root-账号所属密码登录到mysql中">2.4 页面提示输入密码——数据root 账号所属密码，登录到mysql中</h3>
<h3 id="25-create-database-数据库名称-命令创建新数据库">2.5 create database 数据库名称  命令创建新数据库；</h3>
<blockquote>
<p>注：所有的mysql命名末尾一定要加“;”<br>
mysql基本命令：</p>
<p>-h数据库主机<br>
-u用户<br>
-p密码<br>
-P端口号（大写P）</p>
<p>例如：mysql -h127.0.0.1 -uroot -p123456 -P3306<br>
PS:-p密码部分，可以直接指定密码，如果不指定，会提示输入密码。</p>
</blockquote>
<h2 id="3将准备好的sql文件导入到docker中的mysql中">3.将准备好的sql文件导入到docker中的mysql中</h2>
<h3 id="31-备份sql文件存储目录">3.1 备份sql文件存储目录</h3>
<pre><code>/data
</code></pre>
<h3 id="32-查看当前mysql容器名称">3.2 查看当前mysql容器名称</h3>
<pre><code>docker ps
</code></pre>
<h3 id="33-将sql导入mysql">3.3 将sql导入mysql</h3>
<pre><code>docker exec -i mysql5.7 mysql -uroot -p123456 mydb &lt; /data/mydb.sql
</code></pre>
<blockquote>
<p>注：</p>
<p>mydb 为：数据库名</p>
<p>mysql5.7 为：容器名</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MAMP Pro更改文件上传大小限制]]></title>
        <id>https://xiayun.im/post/mamp-pro-settings/</id>
        <link href="https://xiayun.im/post/mamp-pro-settings/">
        </link>
        <updated>2020-04-20T12:10:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>近期由于项目需求，需要上传一些几百MB的文件，但是大文件始终报500错误，连TP5的提示都没给，遂Google一通终得一优解，特此记录。</p>
</blockquote>
<p>主要思路：</p>
<ul>
<li>修改php.ini文件（需为当前项目使用的php版本）</li>
</ul>
<p><mark>（MAMP Pro菜单栏选择File-&gt;Edit Template-&gt;PHP-&gt;选择对应版本即可）</mark></p>
<pre><code>file_uploads = On           ; 是否允许上传文件 On/Off 默认是On
upload_max_filesize = 32M   ; 上传文件的最大限制（改为需求大小即可）
post_max_size = 32M         ; 通过Post提交的最多数据（改为需求大小即可）
</code></pre>
<ul>
<li>考虑网络传输快慢,可以修改一些参数</li>
</ul>
<pre><code>max_execution_time = 30000  ; 脚本最长的执行时间 单位为秒
max_input_time = 600        ; 接收提交的数据的时间限制 单位为秒
memory_limit = 1024M        ; 最大的内存消耗
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css常见单位]]></title>
        <id>https://xiayun.im/post/css-unit/</id>
        <link href="https://xiayun.im/post/css-unit/">
        </link>
        <updated>2020-04-16T03:27:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常见单位">常见单位</h2>
<ol>
<li>px：像素相对长度单位，相对于显示器屏幕分辨率</li>
<li>em：相对长度单位基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li>
<li>rem：相对单位可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</li>
<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li>
<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li>
<li>vmin：vw和vh中较小的那个。</li>
<li>vmax：vw和vh中较大的那个。</li>
<li>%:百分比</li>
<li>in:寸</li>
<li>cm:厘米</li>
<li>mm:毫米</li>
<li>pt:point，大约1/72寸</li>
<li>pc:pica，大约6pt，1/6寸</li>
<li>ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀)</li>
<li>ch:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)</li>
</ol>
<h2 id="常用">常用</h2>
<p>其中用的最多的单位是<strong>px、em、rem</strong>，这三个的区别是：<br>
px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</p>
<p>em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</p>
<p>对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。</p>
<p>rem中的r意思是root（根源），这也就不难理解了。</p>
<p><mark>em/rem</mark>：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。</p>
<p>关于vh/vw与%区别：<br>
vh和vw大小是相对于视口的高度和宽度，而不是父元素的，%单位是相对于包含它的最近的父元素的高度和宽度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[zsh: no matches found不能指定版本]]></title>
        <id>https://xiayun.im/post/tp-composer/</id>
        <link href="https://xiayun.im/post/tp-composer/">
        </link>
        <updated>2020-04-16T02:55:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<pre><code>composer create-project topthink/think=5.0.* tp50 --prefer-dist
</code></pre>
<p>使用composer安装Thinkphp5.0时发生错误</p>
<pre><code># 提示
zsh: no matches found: think=5.0.*
</code></pre>
<h2 id="解决">解决</h2>
<pre><code># 编辑
nano ~/.zshrc
# 添加
setopt no_nomatch 
# 生效
source ~/.zshrc
</code></pre>
<p>再安装即可</p>
]]></content>
    </entry>
</feed>