<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-07-02T14:16:33.651Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[window.location.href跳转问题]]></title>
        <id>https://xiayun.im/post/window-location-href/</id>
        <link href="https://xiayun.im/post/window-location-href/">
        </link>
        <updated>2020-07-02T14:14:44.000Z</updated>
        <content type="html"><![CDATA[<p>window.location.href的赋值，并不会中断Javascript的执行。</p>
<p>因为 LocationChange 行为在浏览器内核中是起定时器异步执行的。<br>
异步执行的好处是为了防止代码调用过深，导致栈溢出，另外也是为了防止递归进入加载逻辑，导致状态紊乱，保证导航请求是顺序执行的。</p>
<p>所以最好在后面加上return这样的语句结束掉。但是return 也只是退出该语句所在的函数，而不会中断整个js文件的执行。<br>
throw new Error()可以中断后面同步代码的执行。</p>
<p>最近在做新项目上线后的异常治理，发现了一个频发的异常</p>
<pre><code class="language-JS">Cannot read property 'XXX' of undefined 
</code></pre>
<p>而这些XXX其实都是解构接口返回的数据，项目中对于HTTP请求做了一层封装，在SSO认证时，没有认证的用户会跳转到SSO登录页。</p>
<pre><code class="language-js">if (data.status === 401) {
    window.location.href = ssoTargetUrl;
    return Promise.resolve();
}
</code></pre>
<p>由于是SPA应用，location.href并不会阻塞打包出来的单一js文件的继续执行，return语句也只会结束其所在函数。导致后续react的渲染进程实际上是在继续的，所以报了一堆类似的无法读取值的错误。</p>
<p>思考到了三个解决方案:</p>
<h4 id="方案一">方案一：</h4>
<pre><code>在页面最开始进行渲染的地方预先发送一个请求以判断其是否登录，未登录则选择不渲染children的元素内容从而避免异常抛出。
</code></pre>
<p>优点： 统一拦截，如果没有登录，不会抛出异常</p>
<p>缺点： 比较考验接口返回的时间，可能会影响首屏时间，几十到几百ms的波动代价</p>
<h4 id="方案二">方案二：</h4>
<pre><code>throw一个error并自定义成关注前端项目质量时相对没有那么注意的一种异常类别
</code></pre>
<p>优点：统一拦截，不会影响首屏时间</p>
<p>缺点：以抛出另一种异常的形式来解决问题并不是一种完美的方式</p>
<h4 id="方案三">方案三：</h4>
<pre><code>在业务代码中做空值的判断处理
</code></pre>
<p>优点：</p>
<p>缺点：改动量大，不能统一处理</p>
<p>如果是你，你会选择哪一种呢？或者有何更好的办法？欢迎与我联系。</p>
<blockquote>
<p>参考: <a href="https://www.zhihu.com/question/29890952">window.location.href跳转页面详细过程是怎么样的？</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git从已有分支拉取新分支]]></title>
        <id>https://xiayun.im/post/git-branch/</id>
        <link href="https://xiayun.im/post/git-branch/">
        </link>
        <updated>2020-06-28T15:38:30.000Z</updated>
        <content type="html"><![CDATA[<p>开发过程中经常用到从master分支copy一个开发分支</p>
<ol>
<li>切换到被copy的分支（master），并且从远端拉取最新版本</li>
</ol>
<pre><code class="language-bash">git checkout master

git pull
</code></pre>
<ol start="2">
<li>从当前分支拉copy开发分支</li>
</ol>
<pre><code class="language-bash">git checkout -b dev
// 提示 Switched to a new branch 'dev'
</code></pre>
<ol start="3">
<li>把新建的分支push到远端</li>
</ol>
<pre><code class="language-bash">git push origin dev
</code></pre>
<ol start="4">
<li>拉取远端分支</li>
</ol>
<pre><code>git pull
</code></pre>
<p>提示：</p>
<pre><code class="language-bash">There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

git branch --set-upstream-to=origin/&lt;branch&gt; dev
</code></pre>
<p>经过验证，当前的分支并没有和本地分支关联，根据提示进行下一步：</p>
<ol start="5">
<li>关联</li>
</ol>
<pre><code class="language-bash">git branch --set-upstream-to=origin/dev
</code></pre>
<blockquote>
<p>注意：这里branch之后都是没有空格的，如果有空格则是错误命令</p>
</blockquote>
<ol start="6">
<li>再次拉取 验证</li>
</ol>
<pre><code>git pull
</code></pre>
<p>done</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to fetch data with React Hooks（转）]]></title>
        <id>https://xiayun.im/post/how-to-fetch-data-with-react-hooks/</id>
        <link href="https://xiayun.im/post/how-to-fetch-data-with-react-hooks/">
        </link>
        <updated>2020-06-21T14:11:32.000Z</updated>
        <content type="html"><![CDATA[<p>How to fetch data with React Hooks？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React哲学]]></title>
        <id>https://xiayun.im/post/react-philosophy/</id>
        <link href="https://xiayun.im/post/react-philosophy/">
        </link>
        <updated>2020-06-17T12:41:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一步将设计好的-ui-划分为组件层级">第一步：将设计好的 UI 划分为组件层级</h2>
<p>如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</p>
<h2 id="第二步用-react-创建一个静态版本">第二步：用 React 创建一个静态版本</h2>
<p>现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。</p>
<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。</p>
<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</p>
<blockquote>
<p>单向数据流</p>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>
<p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中</p>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件</p>
</blockquote>
<h2 id="第三步确定-ui-state-的最小且完整表示">第三步：确定 UI state 的最小（且完整）表示</h2>
<p>为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY: Don’t Repeat Yourself</a>。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p>
<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<h2 id="第四步确定-state-放置的位置">第四步：确定 state 放置的位置</h2>
<p>我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。</p>
<p>对于应用中的每一个 state：</p>
<ol>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ol>
<h2 id="第五步添加反向数据流">第五步：添加反向数据流</h2>
<p>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</p>
<p>本文由react官方文档整理而得</p>
<p><a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks之在比对中执行effects]]></title>
        <id>https://xiayun.im/post/react-hooks-excute-effects/</id>
        <link href="https://xiayun.im/post/react-hooks-excute-effects/">
        </link>
        <updated>2020-06-11T04:50:34.000Z</updated>
        <content type="html"><![CDATA[<p>React 针对 React Elements 前后值进行对比，只去更新 DOM 真正发生改变的部分。对于 Effects，能否有类似这样的理念呢？</p>
<p>某个 Effects 函数一旦执行，函数内的副作用已经发生，React 无法猜测到函数相比于上一次做了哪些变化。但我们可以给 useEffect 传入第二个参数，作为依赖数组 (deps)，避免 Effects 不必要的重复调用。<br>
这个 deps 的含义是：当前 Effect 依赖了哪些变量。</p>
<p>实际应用中，我们不需要在每次组件更新时，都去执行某些 effects，这个时候我们可以给 useEffect 设置依赖，告诉 React 什么时候去执行 useEffect</p>
<p>但有时问题不一定能解决。比如官网就有<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often"> 这样的例子:</a></p>
<pre><code class="language-jsx">const [count, setCount] = useState(0);

useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
}, [count]);


</code></pre>
<p>如果我们频繁修改 count，每次执行 Effect，上一次的计时器被清除，需要调用 setInterval 重新进入时间队列，实际的定期时间被延后，甚至有可能根本没有机会被执行。</p>
<p>但是下面这样的实践方式也不宜采用：</p>
<p>在 Effect 函数中寻找一些变量添加到 deps 中，需要满足条件：其变化时，需要重新触发 effect。</p>
<p>按照这种实践方式，count 变化时，我们并不希望重新 setInterval，故 deps 为空数组。这意味着该 hook 只在组件挂载时运行一次。Effect 中明明依赖了 count，但我们撒谎说它没有依赖，那么当 setInterval 回调函数执行时，获取到的 count 值永远为 0。</p>
<p>遇到这种问题，直接从 deps 移除是不可行的。静下来分析一下，此处为什么要用到 count？能否避免对其直接使用？</p>
<p>可以看到，在 setCount 中用到了 count，为的是把 count 转换为 count + 1 ，然后返回给 React。React 其实已经知道当前的 count，我们需要告知 React 的仅仅是去递增状态，不管它现在具体是什么值。</p>
<p>所以有一个最佳实践：状态变更时，应该通过 setState 的函数形式来代替直接获取当前状态。</p>
<pre><code>setCount(c =&gt; c + 1);
</code></pre>
<p>另外一种场景是：</p>
<pre><code class="language-jsx">const [count, setCount] = useState(0);

useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        console.log(count);
    }, 1000);
    return () =&gt; clearInterval(id);
}, []);
</code></pre>
<p>复制代码在这里，同样的，当count 变化时，我们并不希望重新 setInterval。但我们可以把 count 通过 ref 保存起来。</p>
<pre><code class="language-jsx">const [count, setCount] = useState(0);
const countRef = useRef();
countRef.current = count;

useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        console.log(countRef.current);
    }, 1000);
    return () =&gt; clearInterval(id);
}, []);
</code></pre>
<p>复制代码这样，count 的确不再被使用，而是用 ref 存储了一个在所有帧中共享的变量。</p>
<p>另外的情况是，Effects 依赖了函数或者其他引用类型。与原始数据类型不同的是，在未优化的情况下，每次 render 函数调用时，因为对这些内容的重新创建，其值总是发生了变化，导致 Effects 在使用 deps 的情况下依然会频繁被调用。</p>
<p>对于这个问题，<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">官网的 FAQ </a>已经给出了答案：对于函数，使用 useCallback 避免重复创建；对于对象或者数组，则可以使用 useMemo。从而减少 deps 的变化。</p>
<blockquote>
<p><a href="https://juejin.im/post/5ec7372cf265da76de5cd0c9">原文链接</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks之每一次渲染都有它自己的effects]]></title>
        <id>https://xiayun.im/post/react-hooks-effects/</id>
        <link href="https://xiayun.im/post/react-hooks-effects/">
        </link>
        <updated>2020-06-10T03:20:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react-hooks之每一次渲染都有它自己的effects">React Hooks之每一次渲染都有它自己的effects</h3>
<p>同样通过一个例子来说明：</p>
<pre><code class="language-js">function Counter() {
  const [count, setCount] = useState(0)

  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(`You clicked ${count} times`)
    }, 3000)
  })

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>点击 3 次按钮：</p>
<p>分析：<br>
整个过程组件进行了四次渲染：</p>
<blockquote>
<p>初始化，render0：打印 You clicked 0 times；</p>
<p>修改 count 值为1，render1：打印 You clicked 1 times；</p>
<p>修改 count 值为2，render2：打印 You clicked 2 times；</p>
<p>修改 count 值为3，render3：打印 You clicked 3 times；</p>
<p>通过整个例子我们可以知道，在每次渲染中，useEffect 也是独立的。</p>
</blockquote>
<p>并不是count的值在“不变”的effect中发生了改变，而是effect 函数本身在每一次渲染中都不相同。</p>
<p>每一个effect版本“看到”的count值都来自于它属于的那次渲染：</p>
<pre><code class="language-js">// During first render
function Counter() {
  // ...
  useEffect(
    // Effect function from first render
    setTimeout(() =&gt; {
      console.log(`You clicked ${0} times`)
    }, 3000)
  );
  // ...
}

// After a click, our function is called again
function Counter() {
  // ...
  useEffect(
    // Effect function from second render
    setTimeout(() =&gt; {
      console.log(`You clicked ${1} times`)
    }, 3000)
  );
  // ...
}

// After another click, our function is called again
function Counter() {
  // ...
  useEffect(
    // Effect function from third render
    setTimeout(() =&gt; {
      console.log(`You clicked ${2} times`)
    }, 3000)
  );
  // ..
}

// After another click, our function is called again
function Counter() {
  // ...
  useEffect(
    // Effect function from forth render
    setTimeout(() =&gt; {
      console.log(`You clicked ${3} times`)
    }, 3000)
  );
  // ..
}

</code></pre>
<h3 id="清除-effect">清除 effect</h3>
<p>在 React class 中，你通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它。当我们在 useEffect 中使用了定时器或者添加了某些订阅，可以通过 useEffect 返回一个函数，进行清除定时器或者取消订阅等操作。</p>
<p>看一下例子，在 useEffect 中打印点击的次数：</p>
<pre><code class="language-js">function Example() {
  const [count, setCount] = useState(0)

  useEffect(() =&gt; {
    console.log(`You clicked ${count} times`)
    return() =&gt; {
      console.log('销毁')
    }
  })

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  )

</code></pre>
<p>点击按钮 3 次，控制台中打印的结果如下：</p>
<p>You clicked 0 times<br>
销毁<br>
You clicked 1 times<br>
销毁<br>
You clicked 2 times<br>
销毁<br>
You clicked 3 times</p>
<p>从打印结果我们可以很容易看出，上一次的 effect 是在重新渲染时被清除的。</p>
<p>补充：那么组件的整个重新渲染的过程是怎么样的呢？<br>
假设现在有 render0 和 render1 两次渲染：</p>
<p>React 渲染 render1 的UI;<br>
浏览器绘制，并呈现 render1 的UI；<br>
React 清除 render0 的 effect；<br>
React 运行 render1 的 effect；</p>
<blockquote>
<p>React 只会在浏览器绘制后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks之每一次渲染都有它自己的 Props and State和事件处理函数]]></title>
        <id>https://xiayun.im/post/react-hooks/</id>
        <link href="https://xiayun.im/post/react-hooks/">
        </link>
        <updated>2020-06-10T02:40:23.000Z</updated>
        <content type="html"><![CDATA[<p>React Hooks之每一次渲染都有它自己的 Props and State和事件处理函数,就我个人角度，我将它简单的理解成为一个快照</p>
<h3 id="通过一个例子来说明">通过一个例子来说明：</h3>
<pre><code class="language-js">export default function Example(props) {
  const [times, setTimes] = useState(0);
  const handleClick = () =&gt; {
    setTimeout(() =&gt; {
      alert(`example--${props.count}`);
      setTimes(times + 1);
    }, 3000);
  };
  return (
    &lt;&gt;
      &lt;h1&gt;Example&lt;/h1&gt;
      &lt;p&gt;props.count---{props.count}&lt;/p&gt;
      &lt;p&gt;state.times---{times}&lt;/p&gt;
      &lt;button onClick={handleClick}&gt;alert count&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>重点关注 <Example> 函数组件的代码，其中的 count 属性由父组件传入，初始值为 0，每隔一秒增加 1。点击 &quot;alert count&quot; 按钮，将延迟 3 秒钟弹出 count 的值。<mark>操作后发现，弹窗中出现的值，与页面中文本展示的值不同，而是等于点击 &quot;alert Count&quot; 按钮时 count 的值</mark>。</p>
<p>其中的times属性是组件自身的state，初始值为0，点击 &quot;alert count&quot; 按钮，将延迟 3 秒钟 + 1。如果我在3s内，多次点击按钮，最终它的值并不会是上一次的times值+点击次数*1而是上一次的times+1，这说明只要当点击事件触发时那一刻的times的值没有发生改变，那么无论你在3s内点击多少次，它都是一样的结果。</p>
<p>其点击的快照类似如此：</p>
<pre><code class="language-js">// 第一次点击后3s内的所有点击快照
const handleClick = () =&gt; {
    setTimeout(() =&gt; {
      alert(`example--点击时的props.count`);
      setTimes(0 + 1);
    }, 3000);
  };
</code></pre>
<p>如果更换为 class 组件，它的实现是 <Example2> 这样的：</p>
<pre><code class="language-js">
class Example2 extends Component {
  constructor(props) {
    super(props);
    this.state = {
      times: 0
    };
  }
  handleClick = () =&gt; {
    setTimeout(() =&gt; {
      alert(`example2--${this.props.count}`);
      this.setState({
        times: this.state.times + 1
      });
    }, 3000);
  };
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Example2&lt;/h1&gt;
        &lt;p&gt;{this.props.count}&lt;/p&gt;
        &lt;p&gt;{this.state.times}&lt;/p&gt;
        &lt;button onClick={this.handleClick}&gt;alert count&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

</code></pre>
<p>此时，点击 &quot;alert count&quot; 按钮，延迟 3 秒钟弹出 count 的值，与页面中文本展示的值是一样的。<br>
在某些情况下，<Example> 函数组件中的行为才符合预期。如果将 setTimeout 类比到一次 Fetch 请求，在请求成功时，我要获取的是发起 Fetch 请求前相关的数据，并对其进行修改。</p>
<p>其中的times属性是组件自身的state，初始值为0，点击 &quot;alert count&quot; 按钮，将延迟 3 秒钟 + 1。如果我在3s内，多次点击按钮，最终它的值始终会是上一次的times+1，与hooks组件的表现不一。</p>
<h3 id="如何理解其中的差异">如何理解其中的差异？</h3>
<p>在 <Example2> class 组件中，我们是从 this 中获取到的 props.count。this 是固定指向同一个组件实例的。在 3 秒的延时器生效后，组件重新进行了渲染，this.props 也发生了改变。当延时的回调函数执行时，读取到的 this.props 是当前组件最新的属性值。<br>
而在 <Example> 函数组件中，每一次执行 render 函数时，props 作为该函数的参数传入，它是函数作用域下的变量。</p>
<p>由于 props 是 Example 函数作用域下的变量，可以说对于这个函数的每一次调用中，都产生了新的 props 变量，它在声明时被赋予了当前的属性，他们相互间互不影响。<br>
换一种说法，对于其中任一个 props ，其值在声明时便已经决定，不会随着时间产生变化。handleClick 函数亦是如此。例如定时器的回调函数是在未来发生的，但 props.count 的值是在声明 handleClick 函数时就已经决定好的。</p>
<h3 id="结论">结论：</h3>
<p>在任意一次渲染中，props和state是始终保持不变的。如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的count值。</p>
<p><a href="https://codesandbox.io/s/react-hookszhimeiyicixuanranduyoutazijide-props-and-stateheshijianchulihanshu-syhjb?file=/src/index.js">edit on codesandbox</a></p>
<blockquote>
<p>参考文章：</p>
<p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p>
<p><a href="https://juejin.im/post/5ec7372cf265da76de5cd0c9">React Hooks 最佳实践</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你喜欢哪种朋友——余光中]]></title>
        <id>https://xiayun.im/post/friends/</id>
        <link href="https://xiayun.im/post/friends/">
        </link>
        <updated>2020-06-07T04:31:25.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一个人命里不见得有太太或丈夫但绝对不可没有朋友-即使是荒岛上的鲁滨逊也不免需要一个礼拜五-一个人不能选择父母但是除了鲁滨逊之外每个人都可以选择自己的朋友-照理说选来的东西应该符合自己的理想才对-但是事实又不尽然">一个人命里不见得有太太或丈夫，但绝对不可没有朋友。即使是荒岛上的鲁滨逊，也不免需要一个“礼拜五”。一个人不能选择父母，但是除了鲁滨逊之外，每个人都可以选择自己的朋友。照理说选来的东西，应该符合自己的理想才对。但是事实又不尽然。</h5>
<h5 id="你选别人别人也选你-被选是一种荣誉但不一定是一件乐事-来按你门铃的人很多岂能人人都让你喜出望外呢大致来说按铃的人可分为下列四型">你选别人，别人也选你。被选，是一种荣誉，但不一定是一件乐事。来按你门铃的人很多，岂能人人都让你“喜出望外”呢？大致来说，按铃的人可分为下列四型：</h5>
<h5 id="第一型高级而有趣">第一型，高级而有趣。</h5>
<h5 id="这种朋友理想是理想只是可遇不可求">这种朋友理想是理想，只是可遇不可求。</h5>
<h5 id="世界上高级的人很多有趣的人也很多又高级又有趣的人却少之又少-高级的人使人尊敬有趣的人使人喜欢又高级又有趣的人使人敬而不畏亲而不狎交接愈久芬芳愈醇-譬如新鲜的水果不但甘美可口而且富于营养可谓一举两得-朋友是自己的镜子-一个人有了这样的朋友自己的境界也低不到哪里去-东坡先生杖履所至几曾出现过低级而无趣的俗物呢">世界上高级的人很多，有趣的人也很多，又高级又有趣的人却少之又少。高级的人使人尊敬，有趣的人使人喜欢，又高级又有趣的人，使人敬而不畏，亲而不狎，交接愈久，芬芳愈醇。譬如新鲜的水果，不但甘美可口，而且富于营养，可谓一举两得。朋友是自己的镜子。一个人有了这样的朋友，自己的境界也低不到哪里去。东坡先生杖履所至，几曾出现过低级而无趣的俗物呢。</h5>
<h5 id="第二型高级而无趣">第二型，高级而无趣。</h5>
<h5 id="这种人大概就是古人所谓的诤友甚至是畏友了">这种人大概就是古人所谓的诤友，甚至是畏友了。</h5>
<h5 id="这种朋友有的知识丰富有的人格高超有的呢品学兼优像个模范生可惜美中不足都缺乏一点幽默感活泼不起来-你总觉得他身上有一个窍没打通因此无法豁然恍然具备充分的现实感-跟他交谈即不像打球那样你来我往此呼彼应也不像滚雪球那样把一个有趣的话题越滚越大-精力过人的一类只管自己发球不管你接不接得住-消极的一类则以逸待劳难得接你一球两球-无论对手消极积极总之该你捡球你不捡球这场球是别想打下去的-这种畏友的遗憾在于趣味太窄所以跟你的接触面广不起来-天下之大他从城南跑到城北来找你的目的只在讨论死亡在法国现代小说的特殊意义-为这种畏友捡一晚上的球疲劳是可以想见的-这样的友谊有点像吃药太苦了一点">这种朋友，有的知识丰富，有的人格高超，有的呢，“品学兼优”像个模范生，可惜美中不足，都缺乏一点幽默感，活泼不起来。你总觉得，他身上有一个窍没打通，因此无法豁然恍然，具备充分的现实感。跟他交谈，即不像打球那样，你来我往，此呼彼应，也不像滚雪球那样，把一个有趣的话题越滚越大。精力过人的一类，只管自己发球，不管你接不接得住。消极的一类则以逸待劳，难得接你一球两球。无论对手消极积极，总之该你捡球，你不捡球，这场球是别想打下去的。这种畏友的遗憾，在于趣味太窄，所以跟你的“接触面”广不起来。天下之大，他从城南跑到城北来找你的目的，只在讨论“死亡在法国现代小说的特殊意义”。为这种畏友捡一晚上的球，疲劳是可以想见的。这样的友谊有点像吃药，太苦了一点。</h5>
<h5 id="第三型低级而有趣">第三型，低级而有趣。</h5>
<h5 id="这种朋友极富娱乐价值说笑话他最黄说故事他最像消息他最灵通关系他最广阔好去处他都去过坏主意他都打过-世界上任何话题他都接得下去至于怎么接法就不用你操心了">这种朋友极富娱乐价值，说笑话，他最黄；说故事，他最像；消息，他最灵通；关系，他最广阔；好去处，他都去过；坏主意，他都打过。世界上任何话题他都接得下去，至于怎么接法，就不用你操心了。</h5>
<p>他的全部学问，就在于不让外行人听出他没有学问。至于内行人，世界上有多少内行人呢？所以他的马脚在许多客厅和餐厅里跑来跑去，并不怎么露眼。这种人最会说话，餐桌上有了他，一定宾主尽欢，大家喝进去的美酒还不如听进去的美言那么“沁人心脾”。会议上有了他，再空洞的会议也会显得主题正确，内容充沛，没有白开。如果说，第二类的朋友拥有世界上全部的学问，独缺常识，那么这一型的朋友则恰恰相反，拥有世界上全部的常识，独缺知识。照说低级的人而有趣味，岂非低级趣味，你竟能于他同乐，岂非也有低级趣味之嫌？不过人性是广阔的，谁能保证自己毫无此种不良的成分呢？</p>
<h5 id="如果要你做鲁滨逊你会选第三型的朋友还是第二型的朋友做礼拜五呢">如果要你做鲁滨逊，你会选第三型的朋友还是第二型的朋友做“礼拜五”呢？</h5>
<h5 id="第四型低级而无趣">第四型，低级而无趣。</h5>
<h5 id="这种朋友跟第一型的朋友一样少或然率相当之低">这种朋友，跟第一型的朋友一样少，或然率相当之低。</h5>
<h5 id="这种人当然自有一套价值标准非但不会承认自己低级而无趣恐怕还自以为高级而有趣呢否则余不欲于之同乐矣">这种人当然自有一套价值标准，非但不会承认自己低级而无趣，恐怕还自以为高级而有趣呢？否则，余不欲于之同乐矣。</h5>
<h5 id="亲爱的朋友你是第几型">亲爱的朋友你是第几型？</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js如何实现继承]]></title>
        <id>https://xiayun.im/post/js-extends/</id>
        <link href="https://xiayun.im/post/js-extends/">
        </link>
        <updated>2020-06-01T13:51:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h3 id="1原型链">1.原型链</h3>
<p>在 ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。这一部分另写一篇文章总结，在此不展开了。</p>
<p>缺点：</p>
<ol>
<li>
<p>包含引用类型的原型属性会被所有实例属性共享，容易造成属性的修改混乱。</p>
</li>
<li>
<p>在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
</li>
</ol>
<p>基于以上问题，在实践中很少会单独使用原型链。</p>
<h3 id="2借用构造函数">2.借用构造函数</h3>
<p>借用构造函数的思想主要是在子类型的构造函数中调用父类型构造函数。</p>
<p>例：</p>
<pre><code class="language-js">
function SuperType(name){
    this.name = name;
}

function SubType(){
    // 集成了SuperType，同时还传递了参数
    SuperType.call(this,'pxy');
    
    //实例属性
    this.age = 22;
}
var instance = new SubType();
alert(instance.name); // &quot;pxy&quot;
alert(instance.age); // 22

</code></pre>
<p>优点：可以在子类型构造函数中向超类型构造函数添加参数</p>
<p>缺点：和构造函数模式一样的问题，所有的方法都在构造函数中定义，因此就无法做到函数的复用。而且超类型的原型中定义的方法，对于子类型而言也是不可见的。</p>
<p>基于以上问题，借用构造函数的技术也是很少单独使用的。</p>
<h3 id="3组合继承">3.组合继承</h3>
<pre><code class="language-js">function SuperType(name){
    this.name = name
    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}

SuperType.prototype.sayName = function(){
    console.log(this.name);
}

function SubType(name, age){
    
    //继承属性
    SuperType.call(this,name);

    this.age = age;
}

//继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
    console.log(this.age);
}

var instance1 = new SubType(&quot;driss&quot;,9);
instance1.colors.push(&quot;black&quot;);
console.log(instance1.colors);  //&quot;red,blue,green,black&quot;
instance1.sayName(); // &quot;driss&quot;
instance1.sayAge(); // 9

var instance2 = new SubType(&quot;pan&quot;,10);
console.log(instance2.colors);  //&quot;red,blue,green&quot;
instance2.sayName(); // &quot;pan&quot;
instance2.sayAge(); // 10
</code></pre>
<p>优点：组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof 和 isPropertyOf() 也能够用于识别基于组合继承创建的对象。</p>
<p>缺点：调用了两次超类的构造函数，导致基类的原型对象中增添了不必要的超类的实例对象中的所有属性。</p>
<h3 id="4原型式继承">4.原型式继承</h3>
<p>原型式继承的主要思路是可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。</p>
<p>例:</p>
<pre><code class="language-js">function object(o){
    function F(){};
    F.prototype = o;
    return new F();
}
</code></pre>
<p>简单来说这个函数的作用就是，传入一个对象，返回一个原型对象为该对象的新对象。</p>
<pre><code class="language-js">function object(o){
    function F(){};
    F.prototype = o;
    return new F();
}
var person = {
    name: 'pxy',
    friends: ['tmk','cz','cyx']
}

var anotherPerson = object(person);
anotherPerson.name = 'whg';
anotherPerson.friends.push('wj');

var anotherPerson2 = object(person);
anotherPerson2.name = 'zsl';
anotherPerson2.friends.push('wdw');

console.log(person.friends); //[ 'tmk', 'cz', 'pyr', 'wj', 'wdw' ]

</code></pre>
<p>这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends不仅属于person所有，而且也会被anotherPerson以及anotherPerson2共享。实际上，这就相当于又创建了person对象的两个副本。</p>
<p>ECMAScript 5中新增了 Object.create() 方法规范了原型式继承。这个方法接收两个参数，一个是将被用作新对象原型的对象，一个是为新对象定义额外属性的对象（可选）。</p>
<p>注意第二个参数的格式与 Object.defineProperties() 方法的第二个参数格式相同。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。在第二个参数为空的情况下，该方法与 object() 方法的行为相同。</p>
<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的</p>
<p>优点：可以实现基于一个对象的简单继承，不必创建构造函数</p>
<p>缺点：与原型链中提到的缺点相同，一个是传参的问题，一个是属性共享的问题。</p>
<h3 id="5-寄生式继承">5. 寄生式继承</h3>
<p>寄生式继承的思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回这个对象。</p>
<pre><code class="language-js">function createAnother(original){
    
    var clone = object(original); //通过调用函数创建一个新对象
    
    clone.sayHi = function(){  // 某种方式增强这个对象
        console.log(&quot;hi&quot;);
    }

    return clone;  // 返回这个对象
}

var person = {
    name: &quot;james&quot;
}

var anotherPerson = createAnother(person);

anotherPerson.sayHi(); // &quot;hi&quot;

</code></pre>
<p>这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法</p>
<p>优点： 在主要考虑对象而不是自定义类型和构造函数的情况下，实现简单的继承。</p>
<p>缺点：使用该继承方式，在为对象添加函数的时候，没有办法做到函数的复用。</p>
<h3 id="6寄生式组合继承">6.寄生式组合继承</h3>
<p>前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<p>寄生式组合继承就是用来解决这个问题，它与组合继承不同的地方主要是，在继承原型时，我们继承的不是超类的实例对象，而是原型对象是超类原型对象的一个实例对象，这样就解决了基类的原型对象中增添了不必要的超类的实例对象中的所有属性的问题。</p>
<pre><code class="language-js">function inheritPrototype(subType, superType){

    var prototype = object(superType.prototype); // 创建原型对象是超类原型对象的一个实例对象
  
    prototype.constructor = subType; // 弥补因为重写原型而失去的默认的 constructor 属性。
 
    subType.prototype = prototype; // 实现原型继承
}
</code></pre>
<p>优点：效率高，避免了在 SubType.prototype 上创建不必要的属性。与此同时还能保持原型链不变，开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<blockquote>
<p>参考：<br>
JavaScript高级程序设计（第三版）</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js如何创建对象]]></title>
        <id>https://xiayun.im/post/js-create-object/</id>
        <link href="https://xiayun.im/post/js-create-object/">
        </link>
        <updated>2020-06-01T13:50:10.000Z</updated>
        <content type="html"><![CDATA[<p>最近在学习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：</p>
<ul>
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>构造函数和原型组合模式</li>
<li>动态原型模式</li>
<li>寄生构造模式</li>
<li>稳妥构造模式</li>
</ul>
<h3 id="1工厂模式">1.工厂模式</h3>
<p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽离了创建对象的具体过程。es6的class关键字出现之前，开发人员发明以一种函数，用函数来封装以特定接口创建对象的细节。</p>
<p>例：</p>
<pre><code class="language-js">function Person(name, age){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.greet = function(){
        alert(`Hi, my name is ${this.name}`);
    };
    return o;
}

var person1 = Person(&quot;p1&quot;，21);

var person2 = Person(&quot;p2&quot;，22);
</code></pre>
<p>优点：解决了创建多个相似对象时，代码的复用问题</p>
<p>缺点：</p>
<ol>
<li>无法知道一个对象的具体类型是什么,即无法通过constructor识别对象，以为都是来自Object，无法得知来自Person</li>
<li>每次通过createPerson创建对象的时候，所有的greet方法都是一样的，但是却存储了多次。</li>
</ol>
<h3 id="2构造函数模式">2.构造函数模式</h3>
<p>创建自定义的构造函数，从而定义对象类型的属性和方法。</p>
<p>例：</p>
<pre><code class="language-js">function createPerson(name, age){
    this.name = name;
    this.age = age;
    this.greet = function(){
        alert(`Hi, my name is ${this.name}`);
    };
    return o;
}

var person1 = createPerson(&quot;p1&quot;，21);

var person2 = createPerson(&quot;p2&quot;，22);
</code></pre>
<p>使用构造函数实例化一个对象的时候，对象中会包含一个 <strong>proto</strong> 属性指向构造函数原型对象，而原型对象中则包含一个 constructor 属性指向构造函数。因此在实例对象中我们可以通过原型链来访问到 constructor 属性，从而判断对象的类型。</p>
<p>优点：</p>
<ol>
<li>通过constructor或者instanceof可以识别对象实例的类别</li>
<li>可以通过new 关键字来创建对象实例，更像传统的OO语言中创建对象实例的方式</li>
</ol>
<p>缺点：</p>
<ol>
<li>js 中的函数是对象，在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，就会创建一个 greet 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。</li>
</ol>
<p>注意：</p>
<ol>
<li>构造函数模式隐试的在最后返回return this 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。</li>
<li>也可以根据return this 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。</li>
</ol>
<h3 id="3原型模式">3.原型模式</h3>
<p>我们知道，我们创建的每一个函数都有一个 prototype 属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。我们通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码的复用问题。</p>
<p>例：</p>
<pre><code class="language-js">function Person(){

}

Person.prototype.name = &quot;person&quot;;
Person.prototype.age = 21;
Person.prototype.greet = function(){
    alert(`Hi, my name is ${this.name}`);
};

var person1 = new Person();
person1.greet(); // &quot;Hi, my name is person&quot;

var person2 = new Person();
person2.greet(); // &quot;Hi, my name is person&quot;


console.log(person1.greet === person2.greet) // true
</code></pre>
<p>与构造函数模式不同的是，原型对象上的属性和方法是有所有实例所共享的。也就是说，上面 person1 和 person2 访问的都是同一组属性和同一个 greet() 函数。</p>
<p>优点：</p>
<ol>
<li>greet方法是共享的，所有的实例的greet方法都指向同一个。</li>
<li>可以动态的添加原型对象的方法和属性，并直接反映在对象实例上</li>
</ol>
<p>缺点：</p>
<ol>
<li>首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值。</li>
<li>因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。</li>
<li>第一次调用greet方法或者name属性的时候会搜索两次，第一次是在实例上寻找greet方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实例上添加这些方法或者属性。</li>
</ol>
<p>注意：</p>
<p>优点2中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上</p>
<pre><code>var person1 = new Person()
Person.prototype = {
	name: 'changed person',
	age: 22,
  	greet: function(name){
      console.log('changed');
  	}
}

</code></pre>
<p>这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过__proto__访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的__proto__，并没有跟着一起更新，所以这就导致，实例还访问着原来的Person.prototype，所以建议不要通过这种方式去改变Person.prototype属性</p>
<h3 id="4组合使用构造函数模式和原型模式">4.组合使用构造函数模式和原型模式</h3>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式和原型模式。<mark>构造函数模式用于定义实例属性</mark>，<mark>而原型模式用于定义方法和共享的属性</mark>。使用这种模式的好处就是，每个实例都会拥有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。而且这中混成模式还支持向构造函数传递参数，可以说是及两种模式之长。</p>
<p>例：</p>
<pre><code class="language-js">function Person(name, age){
    this.name = name;
    this.age = age;
    this.country = 'China';
}

Person.prototype.greet = function () {
    alert(`Hi, my name is ${this.name}`);
}

var person1 = new Person('p1', 21);
person1.greet(); // &quot;Hi, my name is p1&quot;

var person2 = new Person('p2', 22);
person2.greet(); // &quot;Hi, my name is p2&quot;

console.log(person1.greet === person2.greet) // true
</code></pre>
<p>优点：</p>
<ol>
<li>解决了原型模式对于引用对象的缺点</li>
<li>解决了原型模式没有办法传递参数的缺点</li>
<li>解决了构造函数模式不能共享方法的缺点</li>
</ol>
<p>缺点：</p>
<ol>
<li>和原型模式中注意1一样</li>
<li>由于使用了两种模式，因此对于代码的封装性来说不是很好。</li>
</ol>
<h3 id="5动态原型模式">5.动态原型模式</h3>
<p>由于上面混成模式存在封装性的问题，动态原型模式是解决这个问题的一个方案。这个方法把所有信息都封装到了构造函数中，而在构造函数中通过判断只初始化一次原型。</p>
<p>例：</p>
<pre><code class="language-js">function Person(name, age){
    this.name = name;
    this.age = age;
    this.country = 'China';
    if(typeof this.greet !== &quot;function&quot; ){
        Person.prototype.greet = function(){
            alert(`Hi, my name is ${this.name}`);
        } 
    } 
}

var person1 = new Person(&quot;p1&quot;, 21);

person1.greet(); // &quot;Hi, my name is p1&quot;
</code></pre>
<p>优点：</p>
<ol>
<li>可以在初次调用构造函数的时候就完成原型对象的修改</li>
<li>修改能体现在所有的实例中</li>
<li>解决了组合模式中封装性的问题</li>
</ol>
<p>缺点：</p>
<ol>
<li>红宝书都说这个方案完美了。。。。</li>
</ol>
<p>注意：</p>
<ol>
<li>只用检查一个在执行后应该存在的方法或者属性就行了</li>
<li>不能用对象字面量修改原型对象</li>
</ol>
<h3 id="6寄生构造模式">6.寄生构造模式</h3>
<p>如果在前面几种模式不适用的情况下，可以使用寄生构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。</p>
<p>例：</p>
<pre><code class="language-js">function Person(name, age){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.greet = function(){
        alert(`Hi, my name is ${this.name}`);
    };
    return o;
}

var person1 = new Person(&quot;p1&quot;，21);

var person2 = new Person(&quot;p2&quot;，22);
</code></pre>
<p>优点：</p>
<ol>
<li>和工厂模式基本一样，除了多了个new操作符</li>
</ol>
<p>缺点：</p>
<ol>
<li>和工厂模式一样，不能区分实例的类别</li>
</ol>
<h3 id="7稳妥构造模式">7.稳妥构造模式</h3>
<p>Douglas Crockford 发明了 JavaScript 中的稳妥对象这个概念。所谓稳妥对象，指的就是，没有公共属性，而且其方法也不使用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用。</p>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：</p>
<p>一是新创建的对象的实例方法不引用 this ；</p>
<p>二是不使用 new 操作符调用构造函数。</p>
<p>例：</p>
<pre><code class="language-js">function Person(name, age){

    //创建要返回的对象
    var o = new Object();

    //可以在这里定义私有变量和函数

    //添加方法
    o.greet = function(){
        alert(`Hi, my name is ${this.name}`);
    }

    //返回对象
    return o;
} 

var person1 =  Person('safe name');

person1.greet(); // &quot;Hi, my name is safe name&quot;
</code></pre>
<p>优点：</p>
<ol>
<li>以上面为例，除了 greet 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。</li>
</ol>
<p>缺点：<br>
2. 和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型</p>
<blockquote>
<p>参考：<br>
JavaScript高级程序设计（第三版）</p>
</blockquote>
]]></content>
    </entry>
</feed>