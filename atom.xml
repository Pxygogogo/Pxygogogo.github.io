<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-05-20T15:17:38.548Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[react中通过props给子组件传值，父组件setState后props不能同步更新的问题]]></title>
        <id>https://xiayun.im/post/react-props-state/</id>
        <link href="https://xiayun.im/post/react-props-state/">
        </link>
        <updated>2020-05-20T14:48:59.000Z</updated>
        <content type="html"><![CDATA[<p>一、业务场景</p>
<p>父组件给子组件一个数据列表后，增删改都在子组件中进行</p>
<p>实现思路：父组件将数据列表以props的形式传递给子组件，子组件将这个props赋值给自身的state，之后的增删改就更新自身的state值，以实现局部刷新。</p>
<p>二、一个demo实现</p>
<p><mark>强烈推荐使用codesandbox.io进行demo操作</mark></p>
<pre><code class="language-js">import { render } from 'react-dom'
import React from 'react'

class Child extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: props.list
    }
  }

  handleCilck = () =&gt; {
    this.setState({
      list: this.state.list.concat({ name: 'sarah' })
    })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleCilck}&gt;添加&lt;/button&gt;
        {this.state.list.map((item, index) =&gt; {
          return &lt;h1 key={index}&gt;Hello, {item.name}&lt;/h1&gt;
        })}
      &lt;/div&gt;
    )
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: [{ name: 'lily' }, { name: 'bob' }]
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Child list={this.state.list} /&gt;;
      &lt;/div&gt;
    )
  }
}

render(&lt;Parent /&gt;, document.getElementById('root'))
</code></pre>
<p><strong>这个demo会产生一个问题，如果父组件传递给子组件的props改变了，子组件渲染的列表数据却不会对应发生改变。</strong></p>
<p>原因：父组件更新导致子组件更新时，子组件的生命周期执行顺序如下：</p>
<pre><code class="language-js">componentWillReceiveProps(UNSAFE_componentWillReceiveProps) 
// componentWillReceiveProps is deprecated since React 16.9.0, use UNSAFE_componentWillReceiveProps instead
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate
</code></pre>
<p><mark><strong>也就是说子组件刷新的时候，父组件传递给子组件的props发生改变，引发子组件的render，并没有执行子组件的constructor函数，子组件没有被卸载自然不会重新加载，只会重新render，而如果父组件的props传递给子组件的state，那么子组件的state只会在第一次加载的时候被赋值，后续的父组件props变化并不会被赋值到子组件的state上，还是要理解组件的声明周期函数，以及各个函数在什么时候会被调用。</strong></mark></p>
<p>解决方案：在UNSAFE_componentWillReceiveProps中重新对state赋值。</p>
<pre><code class="language-js">UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      list: nextProps.list
    })
}

</code></pre>
<p>接着给子组件添加修改功能</p>
<p>js部分:</p>
<pre><code class="language-js">handleModify = () =&gt; {
    let newArray = this.state.list
    newArray[0].name = 'natasha'
    this.setState({
      list: newArray
    })
  }
</code></pre>
<p>jsx部分:</p>
<pre><code class="language-html">&lt;button onClick={this.handleAdd}&gt;添加&lt;/button&gt;
</code></pre>
<p>如果直接这样做又会引发一个新的问题</p>
<p>因为list是引用类型，这样更改的话，不仅更改了子组件自身的state，还更改了父组件传递进来的props，也就是父组件的state.list的值。</p>
<p>因此在更改引用类型的数据时，应该采用浅拷贝或者深拷贝的方式</p>
<p>三、总结</p>
<p>总结以上demo实践，父组件用props赋值给子组件的state时，需要注意两点：</p>
<p>1.在生命周期UNSAFE_componentWillReceiveProps中重新赋值</p>
<p>2.用深拷贝创建不可变类型引用数据</p>
<blockquote>
<p>react官方文档讲的挺好</p>
<p>参考资料：</p>
<p><a href="https://www.azimiao.com/6316.html">文章一</a></p>
<p><a href="https://www.jianshu.com/p/19c4dc3394f0">文章二</a></p>
<p><a href="https://segmentfault.com/q/1010000008387645">文章三</a></p>
<p><a href="https://blog.csdn.net/RuiKe1400360107/article/details/89554600">文章四</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react setState修改嵌套对象]]></title>
        <id>https://xiayun.im/post/react-setstate-complex-datastruct/</id>
        <link href="https://xiayun.im/post/react-setstate-complex-datastruct/">
        </link>
        <updated>2020-05-19T14:39:52.000Z</updated>
        <content type="html"><![CDATA[<p>在开发过程中,时常会在state中遇到一些比较复杂的数据结构,类似下面这样的:</p>
<pre><code class="language-js">state = {
     list: {
        objA: {
          name: 'A',
          age: 20
        },
        objB: {
          name: 'B',
          age: 25
        },
        objC: {
          show: false
        },
        objD: 'D'
      }
}
</code></pre>
<p>这时需要我们修改list中objA中的name属性和objD的属性,遇到这样的情况我们一般会使用什么办法解决呢?其实有三种解决方案:</p>
<h3 id="方案一作用于对象中的深层级和第一层级">方案一(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">this.setState({
     list: {
         ...this.state.list,
          objA: {
            ...this.state.list.objA,
            name: 'A1'
            }
        }
    })
</code></pre>
<h3 id="方案二作用对象中的第一层级">方案二(作用对象中的第一层级):</h3>
<pre><code class="language-js">    let data = Object.assign({}, this.state.list, {objD: 'D1'})
    this.setState({
        list: data
    })
</code></pre>
<h3 id="方案三作用于对象中的深层级和第一层级">方案三(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">    let data = this.state.list;
    data.objA.name = 'A1';
    data.objD = 'D1';
    this.setState({
        list: data
    })
</code></pre>
<p>总结:</p>
<table>
<thead>
<tr>
<th style="text-align:center">方案</th>
<th style="text-align:center">适用范围</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方案一</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">写法麻烦,单次对象赋值,对象层级多的时候,容易遗漏</td>
</tr>
<tr>
<td style="text-align:center">方案二</td>
<td style="text-align:center">只适用与第一层级</td>
<td style="text-align:center">只适用第一层级</td>
</tr>
<tr>
<td style="text-align:center">方案三</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">若存在深层及和单一层级的,需要多次赋值</td>
</tr>
</tbody>
</table>
<p>这三种写法都可以,使用哪一种方案,还需要根据业务来定</p>
<p><a href="https://blog.csdn.net/weixin_34191845/article/details/89596546?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react复制内容到剪切板]]></title>
        <id>https://xiayun.im/post/copy-to-clipboard/</id>
        <link href="https://xiayun.im/post/copy-to-clipboard/">
        </link>
        <updated>2020-05-18T14:31:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react-copy-to-clipboard插件">react-copy-to-clipboard插件</h3>
<p>一个react插件，npm安装即可。<br>
优点：查看官方示例，上手简单，兼容性扩展性会比较强<br>
缺点：截止发文，最新版5.0.2版包大小达到了37.2kb，对于一个在项目中使用不多的需求有些浪费。</p>
<h3 id="原生js实现">原生js实现</h3>
<h4 id="documentexeccommand方法">document.execCommand()方法</h4>
<p><a href="hhttps://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">MDN上定义：</a></p>
<p>当一个HTML文档切换到设计模式时，document暴露 execCommand 方法，该方法允许运行命令来操纵<mark>可编辑内容区域</mark>的元素。</p>
<p>再看可编辑内容区域（contenteditable）的定义</p>
<p>全局属性 contenteditable  是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。</p>
<p>也就是意味着除了 <mark><input>、<textarea></mark> 这样的输入域以外，是无法使用这个方法的</p>
<p>如果是需要获取input和textarea的值然后复制的，可以直接通过获取元素节点后通过select方法选中后直接调用document.execCommand('copy')即可</p>
<p>样例：</p>
<pre><code class="language-js">    const btn = document.querySelector('#btn');
    btn.addEventListener('click',() =&gt; {
        const input = document.createElement('input');
        input.setAttribute('readonly', 'readonly');
        input.setAttribute('value', 'hello world!');
        document.body.appendChild(input);
        input.select();
        if (document.execCommand('copy')) {
            document.execCommand('copy');
            console.log('复制成功');
        }
        document.body.removeChild(input);
    })
</code></pre>
<blockquote>
<p>如果需要隐藏新创建的元素时需要注意不能通过设置display值为none来实现，因为设置为none后将无法获取元素的属性值包括value，上一篇文章仔细探讨了display：none和visibility：hidden区别</p>
</blockquote>
<h4 id="createtextrange">createTextRange()</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range">MDN上对于range定义：</a></p>
<p>Range 接口表示一个包含节点与文本节点的一部分的文档片段。</p>
<p>可以用 Document 对象的 Document.createRange 方法创建 Range，也可以用 Selection 对象的 getRangeAt 方法获取 Range。另外，还可以通过 Document 对象的构造函数 Range() 来得到 Range</p>
<p>其原理与上种方法大同小异</p>
<p>样例：</p>
<pre><code class="language-js">        var div = document.getElementById('div1');
        if (document.body.createTextRange) {
            var range = document.body.createTextRange();
            range.moveToElementText(div);
            range.select();
        } else if (window.getSelection) {
            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(div);
            selection.removeAllRanges();
            selection.addRange(range);
        } else {
            console.warn(&quot;none&quot;);
        }
        document.execCommand(&quot;copy&quot;)
</code></pre>
<p><a href="https://www.cnblogs.com/dch0/p/12674129.html">参考一</a></p>
<p><a href="https://www.jb51.net/article/135605.htm">参考二</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[display none与visibility hidden的区别]]></title>
        <id>https://xiayun.im/post/display-visibility/</id>
        <link href="https://xiayun.im/post/display-visibility/">
        </link>
        <updated>2020-05-18T14:30:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>面试题常考，以为自己足够理解，但第一次在真实场景中使用还是<br>
没有注意，记录之，自省！</p>
</blockquote>
<h2 id="联系它们都能让元素不可见">联系：它们都能让元素不可见</h2>
<h2 id="区别">区别：</h2>
<h3 id="其一">其一</h3>
<ul>
<li>display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；</li>
<li>visibility: hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见</li>
</ul>
<h3 id="其二">其二</h3>
<ul>
<li>visibility:hidden; 使用该属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。</li>
<li>display:none; 使用该属性后，HTML元素（对象）的权度、高度等各种属性值都将“丢失”。</li>
</ul>
<h3 id="其三">其三</h3>
<ul>
<li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；</li>
<li>visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显示</li>
</ul>
<h3 id="其四">其四</h3>
<p>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</p>
<h3 id="其五">其五</h3>
<p>读屏器不会读取display: none;元素内容,会读取visibility: hidden;元素内容</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react中获取属性的问题]]></title>
        <id>https://xiayun.im/post/react-get-attribute/</id>
        <link href="https://xiayun.im/post/react-get-attribute/">
        </link>
        <updated>2020-05-13T14:12:40.000Z</updated>
        <content type="html"><![CDATA[<p>react 获取属性的问题，currentTarget确实是可以的，target确实是有问题的</p>
<p>父节点有属性data-cc 这时候点击父节点获取属性</p>
<p>正确方式是 event.currentTarget.getAttribute(“data-cc”)</p>
<p>而不是event.target.getAttribute(“data-cc”)</p>
<p>ps:</p>
<p>currentTarget 返回其事件监听器触发该事件的元素。 target 返回触发此事件的元素（事件的目标节点）。<br>
react添加自定义属性必须是 data-xx 形式<br>
最简单直白理解event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素</p>
<p>关于currentTarget和target详细区别见下篇文章</p>
<p><a href="https://blog.csdn.net/fortunegrant/article/details/83754945">原文地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[package.json和package-lock.json的区别]]></title>
        <id>https://xiayun.im/post/package.json-package.lock.json/</id>
        <link href="https://xiayun.im/post/package.json-package.lock.json/">
        </link>
        <updated>2020-05-11T14:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>package.json:</p>
<p>主要用来定义项目中需要依赖的包</p>
<p>package-lock.json：</p>
<p>根据官方文档，package-lock.json是生成的系统当前安装的库的具体来源和版本号，锁定版本。在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</p>
<p>当你执行npm install的时候， node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，node是从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。</p>
<p>当package.json与package-lock.json都不存在，执行&quot;npm install&quot;时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件，此时，你可以通过&quot;npm init --yes&quot;来生成package.json文件</p>
<p>参考：https://blog.csdn.net/u013992330/java/article/details/81110018</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css踩坑之z-index]]></title>
        <id>https://xiayun.im/post/css-z-index/</id>
        <link href="https://xiayun.im/post/css-z-index/">
        </link>
        <updated>2020-05-11T14:36:28.000Z</updated>
        <content type="html"><![CDATA[<p>z-index 属性指定一个元素的堆叠顺序<br>
拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面</p>
<p><mark>注意！！！： z-index 只适用于已定位的元素(position:absolute, position:relative, or position:fixed)</mark></p>
<p>所以z-index是一种依赖属性，依赖position属性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux和Flux]]></title>
        <id>https://xiayun.im/post/redux-and-flux/</id>
        <link href="https://xiayun.im/post/redux-and-flux/">
        </link>
        <updated>2020-05-11T14:35:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="flux">Flux</h2>
<h3 id="flux-优点">Flux 优点</h3>
<ul>
<li><strong>最重要的就是“<mark>单向数据流</mark>”的管理方式</strong>。在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</li>
</ul>
<p>解决的MVC的问题:</p>
<blockquote>
<p>MVC最大的问题就是无法禁绝View和Model之间的直接对话，对应于MVC中View就是Flux中的View，对应于MVC中的Model的就是Flux中的Store，在Flux中，Store只有get方法，没有set方法，根本可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action对象给Dispatcher</p>
</blockquote>
<h3 id="flux-不足">Flux 不足</h3>
<ol>
<li>Store之间依赖关系</li>
<li>难以进行服务器端渲染</li>
<li>Store混杂了逻辑和状态</li>
</ol>
<h2 id="redux">Redux</h2>
<p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p>
<p>Flux的基本原则是“单向数据流”,</p>
<p>Redux在此基础上强调三个基本原则：</p>
<ul>
<li>唯一数据源（Single Source of Truth）；</li>
</ul>
<p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。这个唯一Store上的状态，是一个树形的对象，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题</p>
<ul>
<li>保持状态只读（State is read-only）；</li>
</ul>
<p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p>
<ul>
<li>数据改变只能通过纯函数完成（Changes are made with pure functions）。</li>
</ul>
<p>这里所说的纯函数就是Reducer, Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。就以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer, reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次参数reducer，通过reducer函数完成规约所有元素的功能.</p>
<blockquote>
<p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的UI=render(state)思想完全契合</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux理解]]></title>
        <id>https://xiayun.im/post/redux-learning/</id>
        <link href="https://xiayun.im/post/redux-learning/">
        </link>
        <updated>2020-05-10T03:57:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/05/09/YMT4Hg.jpg" alt="redux工作流程" loading="lazy"></figure>
<ol>
<li>一个比喻：</li>
</ol>
<ul>
<li>component --- 读者</li>
<li>store --- 图书馆</li>
<li>reducer --- 图书管理员</li>
<li>action --- 读者的动作</li>
</ul>
<ol start="2">
<li>流程理解</li>
</ol>
<ul>
<li>所有component的数据状态均来自统一的store中</li>
<li>如果需要更新store中的数据，需要在对应的事件中定义一个action，action就是一个对象，这个对象一般有两个属性，第一个是对action的描述，第二个是要改变的值</li>
<li>action会通过dispatch方法将type和value通过store的自动推送策略直接传递给reducer（虚线的作用）</li>
<li>reducer的两个参数</li>
</ul>
<blockquote>
<p>state：指的是原始仓库里的状态</p>
<p>action: 指的是action新传递的状态</p>
</blockquote>
<ul>
<li>reducer中不能直接修改state，需要深拷贝一个state对象，然后在新的state对象上操作，并最终返回新的state</li>
</ul>
<ol start="3">
<li>注意点</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux小技巧]]></title>
        <id>https://xiayun.im/post/redux-tips/</id>
        <link href="https://xiayun.im/post/redux-tips/">
        </link>
        <updated>2020-05-10T03:56:27.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>把Action Types单独写入一个文件<br>
单独出来的原因：</li>
</ol>
<ul>
<li>这些Types如果不统一管理，不利于大型项目的服用，设置会长生冗余代码。</li>
<li>因为Action里的Type，一定要和Reducer里的type一一对应在，所以这部分代码或字母写错后，浏览器里并没有明确的报错，这给调试带来了极大的困难。</li>
</ul>
<p>例：</p>
<pre><code class="language-js">// 导出 目录：src/store/actionTypes.js
export const  CHANGE_INPUT = 'changeInput'
export const  ADD_ITEM = 'addItem'
export const  DELETE_ITEM = 'deleteItem'

// 引入
import { CHANGE_INPUT , ADD_ITEM , DELETE_ITEM } from './store/actionTypes'
</code></pre>
<ol start="2">
<li>把所有的Redux Action放到一个文件里进行管理</li>
</ol>
<p>例：</p>
<pre><code>// 目录：src/store/actionCreators.js
import {CHANGE_INPUT}  from './actionTypes'

export const changeInputAction = (value)=&gt;({
    type:CHANGE_INPUT,
    value
})
// 引入
import {changeInputAction} from './store/actionCreatores'
changeInputValue(e){
    const action = changeInputAction(e.target.value)
    store.dispatch(action)
}
</code></pre>
<ol start="3">
<li>redux三个小坑</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
<ol start="4">
<li>可选的好方式</li>
</ol>
<ul>
<li>UI和业务逻辑分离</li>
<li>无状s态组件</li>
</ul>
]]></content>
    </entry>
</feed>