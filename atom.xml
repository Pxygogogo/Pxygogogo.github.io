<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-05-20T15:23:12.999Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[给我的孩子们——丰子恺]]></title>
        <id>https://xiayun.im/post/to-my-child/</id>
        <link href="https://xiayun.im/post/to-my-child/">
        </link>
        <updated>2020-05-20T15:19:43.000Z</updated>
        <content type="html"><![CDATA[<p>我的孩子们！我憧憬于你们的生活，每天不止一次！我想委曲地说出来，使你们自己晓得。可惜到你们懂得我的话的意思的时候，你们将不复是可以使我憧憬的人了。这是何等可悲哀的事啊！</p>
<p>瞻瞻！你尤其可佩服。你是身心全部公开的真人。你甚么事体（什么事情）都想拼命地用全副精力去对付。小小的失意，象花生米翻落地了，自己嚼了舌头了，小猫不肯吃糕了，你都要哭得嘴唇翻白，昏去一两分钟。外婆普陀去烧香买回来给你的泥人，你何等鞠躬尽瘁地抱他，喂他；有一天你自己失手把他打破了，你的号哭的悲哀，比大人们的破产、失恋、丧考妣、全军覆没的悲哀都要真切。两把芭蕉扇做的脚踏车，麻雀牌堆成的火车、汽车，你何等认真地看待，挺直了嗓子叫“汪——，”“咕咕咕……”，来代替汽油。宝姊姊讲故事给你听，说到“月亮姊姊挂下一只篮来，宝姊姊坐在篮里吊了上去，瞻瞻在下面看”的时候，你何等激昂地同她争，说“瞻瞻要上去，宝姊姊在下面看！”甚至哭到漫姑面前去求审判。我每次剃了头，你真心地疑我变了和尚，好几时不要我抱。最是今年夏天，你坐在我膝上发现了我腋下的长毛，当作黄鼠狼的时候，你何等伤心，你立刻从我身上爬下去，起初眼瞪瞪地对我端相，继而大失所望地号哭，看看，哭哭，如同对被判定了死罪的亲友一样。你要我抱你到车站里去，多多益善地要买香蕉，满满地擒了两手回来，回到门口时你已经熟睡在我的肩上，手里的香蕉不知落在哪里去了。这是何等可佩服的真率、自然与热情！大人间的所谓“沉默”、“含蓄”、“深刻”的美德，比起你来，全是不自然的、病的、伪的！</p>
<p>你们每天做火车、做汽车、办酒、请菩萨、堆六面画，唱歌、全是自动的，创造创作的生活。大人们的呼号“归自然！”“生活的艺术化！”“劳动的艺术化！”在你们面前真是出丑得很了！依样画几笔画，写几篇文的人称为艺术家、创作家，对你们更要愧死！</p>
<p>你们的创作力，比大人真是强盛得多哩：瞻瞻！你的身体不及椅子的一半，却常常要搬动它，与它一同翻倒在地上；你又要把一杯茶横转来藏在抽斗里，要皮球停在壁上，要拉住火车的尾巴，要月亮出来，要天停止下雨。在这等小小的事件中，明明表示着你们的弱小的体力与智力不足以应付强盛的创作欲、表现欲的驱使，因而遭逢失败。然而你们是不受大自然的支配，不受人类社会的束缚的创造者，所以你的遭逢失败，例如火车尾巴拉不住，月亮呼不出来的时候，你们决不承认是事实的不可能，总以为是爹爹妈妈不肯帮你们办到，同不许你们弄自鸣钟同例，所以愤愤地哭了，你们的世界何等广大！</p>
<p>你们一定想：终天无聊地伏在案上弄笔的爸爸，终天闷闷地坐在窗下弄引线的妈妈，是何等无气性的奇怪的动物！你们所视为奇怪动物的我与你们的母亲，有时确实难为了你们，摧残了你们，回想起来，真是不安心得很！</p>
<p>阿宝！有一晚你拿软软的新鞋子，和自己脚上脱下来的鞋子，给凳子的脚穿了，刬袜立在地上，得意地叫“阿宝两只脚，凳子四只脚”的时候，你母亲喊着“龌龊了袜子！”立刻擒你到藤榻上，动手毁坏你的创作。当你蹲在榻上注视你母亲动手毁坏的时候，你的小心里一定感到“母亲这种人，何等煞风景而野蛮”罢！</p>
<p>瞻瞻！有一天开明书店送了几册新出版的毛边的《音乐入门》来。我用小刀把书页一张一张地裁开来，你侧着头，站在桌边默默地看。后来我从学校回来，你已经在我的书架上拿了一本连史纸印的中国装的《楚辞》，把它裁破了十几页，得意地对我说：“爸爸！瞻瞻也会裁了！”瞻瞻！这在你原是何等成功的欢喜，何等得意的作品！却被我一个惊骇的“哼！”字喊得你哭了。那时候你也一定抱怨“爸爸何等不明”罢！</p>
<p>软软！你常常要弄我的长锋羊毫，我看见了总是无情地夺脱你。现在你一定轻视我，想道：“你终于要我画你的画集的封面！”</p>
<p>最不安心的，是有时我还要拉一个你们所最怕的陆露沙医生来，叫他用他的大手来摸你们的肚子，甚至用刀来在你们臂上割几下，还要叫妈妈和漫姑擒住了你们的手脚，捏住了你们的鼻子，把很苦的水灌到你们的嘴里去。这在你们一定认为是太无人道的野蛮举动罢！</p>
<p>孩子们！你们果真抱怨我，我倒欢喜；到你们的抱怨变为感激的时候，我的悲哀来了！</p>
<p>我在世间，永没有逢到象你们这样出肺肝相示的人。世间的人群结合，永没有象你们样的彻底地真实而纯洁。最是我到上海去干了无聊的所谓“事”回来，或者去同不相干的人们做了叫做“上课”的一种把戏回来，你们在门口或车站旁等我的时候，我心中何等惭愧又欢喜！惭愧我为甚么去做这等无聊的事，欢喜我又得暂时放怀一切地加入你们的真生活的团体。</p>
<p>但是，你们的黄金时代有限，现实终于要暴露的。这是我经验过来的情形也是大人们谁也经验过的情形。我眼看见儿时的伴侣中的英雄、好汉，一个个退缩、顺从、妥协、屈服起来，到象绵羊的地步。我自己也是如此。“后之视今，亦犹今之视昔”，你们不久也要走这条路呢？</p>
<p>我的孩子们！憧憬于你们的生活的我，痴心要为你们永远挽留这黄金时代在这册子里。</p>
<p>然这真不过象“蜘蛛网落花”，略微保留一点春的痕迹而已。且到你们懂得我这片心情的时候，你们早已不是这样的人，我的画在世间已无可印证了！这是何等可悲哀的事啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react中通过props给子组件传值，父组件setState后props不能同步更新的问题]]></title>
        <id>https://xiayun.im/post/react-props-state/</id>
        <link href="https://xiayun.im/post/react-props-state/">
        </link>
        <updated>2020-05-20T14:48:59.000Z</updated>
        <content type="html"><![CDATA[<p>一、业务场景</p>
<p>父组件给子组件一个数据列表后，增删改都在子组件中进行</p>
<p>实现思路：父组件将数据列表以props的形式传递给子组件，子组件将这个props赋值给自身的state，之后的增删改就更新自身的state值，以实现局部刷新。</p>
<p>二、一个demo实现</p>
<p><mark>强烈推荐使用codesandbox.io进行demo操作</mark></p>
<pre><code class="language-js">import { render } from 'react-dom'
import React from 'react'

class Child extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: props.list
    }
  }

  handleCilck = () =&gt; {
    this.setState({
      list: this.state.list.concat({ name: 'sarah' })
    })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleCilck}&gt;添加&lt;/button&gt;
        {this.state.list.map((item, index) =&gt; {
          return &lt;h1 key={index}&gt;Hello, {item.name}&lt;/h1&gt;
        })}
      &lt;/div&gt;
    )
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: [{ name: 'lily' }, { name: 'bob' }]
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Child list={this.state.list} /&gt;;
      &lt;/div&gt;
    )
  }
}

render(&lt;Parent /&gt;, document.getElementById('root'))
</code></pre>
<p><strong>这个demo会产生一个问题，如果父组件传递给子组件的props改变了，子组件渲染的列表数据却不会对应发生改变。</strong></p>
<p>原因：父组件更新导致子组件更新时，子组件的生命周期执行顺序如下：</p>
<pre><code class="language-js">componentWillReceiveProps(UNSAFE_componentWillReceiveProps) 
// componentWillReceiveProps is deprecated since React 16.9.0, use UNSAFE_componentWillReceiveProps instead
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate
</code></pre>
<p><mark><strong>也就是说子组件刷新的时候，父组件传递给子组件的props发生改变，引发子组件的render，并没有执行子组件的constructor函数，子组件没有被卸载自然不会重新加载，只会重新render，而如果父组件的props传递给子组件的state，那么子组件的state只会在第一次加载的时候被赋值，后续的父组件props变化并不会被赋值到子组件的state上，还是要理解组件的声明周期函数，以及各个函数在什么时候会被调用。</strong></mark></p>
<p>解决方案：在UNSAFE_componentWillReceiveProps中重新对state赋值。</p>
<pre><code class="language-js">UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      list: nextProps.list
    })
}

</code></pre>
<p>接着给子组件添加修改功能</p>
<p>js部分:</p>
<pre><code class="language-js">handleModify = () =&gt; {
    let newArray = this.state.list
    newArray[0].name = 'natasha'
    this.setState({
      list: newArray
    })
  }
</code></pre>
<p>jsx部分:</p>
<pre><code class="language-html">&lt;button onClick={this.handleAdd}&gt;添加&lt;/button&gt;
</code></pre>
<p>如果直接这样做又会引发一个新的问题</p>
<p>因为list是引用类型，这样更改的话，不仅更改了子组件自身的state，还更改了父组件传递进来的props，也就是父组件的state.list的值。</p>
<p>因此在更改引用类型的数据时，应该采用浅拷贝或者深拷贝的方式</p>
<p>三、总结</p>
<p>总结以上demo实践，父组件用props赋值给子组件的state时，需要注意两点：</p>
<p>1.在生命周期UNSAFE_componentWillReceiveProps中重新赋值</p>
<p>2.用深拷贝创建不可变类型引用数据</p>
<blockquote>
<p>react官方文档讲的挺好</p>
<p>参考资料：</p>
<p><a href="https://www.azimiao.com/6316.html">文章一</a></p>
<p><a href="https://www.jianshu.com/p/19c4dc3394f0">文章二</a></p>
<p><a href="https://segmentfault.com/q/1010000008387645">文章三</a></p>
<p><a href="https://blog.csdn.net/RuiKe1400360107/article/details/89554600">文章四</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react setState修改嵌套对象]]></title>
        <id>https://xiayun.im/post/react-setstate-complex-datastruct/</id>
        <link href="https://xiayun.im/post/react-setstate-complex-datastruct/">
        </link>
        <updated>2020-05-19T14:39:52.000Z</updated>
        <content type="html"><![CDATA[<p>在开发过程中,时常会在state中遇到一些比较复杂的数据结构,类似下面这样的:</p>
<pre><code class="language-js">state = {
     list: {
        objA: {
          name: 'A',
          age: 20
        },
        objB: {
          name: 'B',
          age: 25
        },
        objC: {
          show: false
        },
        objD: 'D'
      }
}
</code></pre>
<p>这时需要我们修改list中objA中的name属性和objD的属性,遇到这样的情况我们一般会使用什么办法解决呢?其实有三种解决方案:</p>
<h3 id="方案一作用于对象中的深层级和第一层级">方案一(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">this.setState({
     list: {
         ...this.state.list,
          objA: {
            ...this.state.list.objA,
            name: 'A1'
            }
        }
    })
</code></pre>
<h3 id="方案二作用对象中的第一层级">方案二(作用对象中的第一层级):</h3>
<pre><code class="language-js">    let data = Object.assign({}, this.state.list, {objD: 'D1'})
    this.setState({
        list: data
    })
</code></pre>
<h3 id="方案三作用于对象中的深层级和第一层级">方案三(作用于对象中的深层级和第一层级):</h3>
<pre><code class="language-js">    let data = this.state.list;
    data.objA.name = 'A1';
    data.objD = 'D1';
    this.setState({
        list: data
    })
</code></pre>
<p>总结:</p>
<table>
<thead>
<tr>
<th style="text-align:center">方案</th>
<th style="text-align:center">适用范围</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方案一</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">写法麻烦,单次对象赋值,对象层级多的时候,容易遗漏</td>
</tr>
<tr>
<td style="text-align:center">方案二</td>
<td style="text-align:center">只适用与第一层级</td>
<td style="text-align:center">只适用第一层级</td>
</tr>
<tr>
<td style="text-align:center">方案三</td>
<td style="text-align:center">多层级和单一层级都存在</td>
<td style="text-align:center">若存在深层及和单一层级的,需要多次赋值</td>
</tr>
</tbody>
</table>
<p>这三种写法都可以,使用哪一种方案,还需要根据业务来定</p>
<p><a href="https://blog.csdn.net/weixin_34191845/article/details/89596546?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react复制内容到剪切板]]></title>
        <id>https://xiayun.im/post/copy-to-clipboard/</id>
        <link href="https://xiayun.im/post/copy-to-clipboard/">
        </link>
        <updated>2020-05-18T14:31:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react-copy-to-clipboard插件">react-copy-to-clipboard插件</h3>
<p>一个react插件，npm安装即可。<br>
优点：查看官方示例，上手简单，兼容性扩展性会比较强<br>
缺点：截止发文，最新版5.0.2版包大小达到了37.2kb，对于一个在项目中使用不多的需求有些浪费。</p>
<h3 id="原生js实现">原生js实现</h3>
<h4 id="documentexeccommand方法">document.execCommand()方法</h4>
<p><a href="hhttps://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">MDN上定义：</a></p>
<p>当一个HTML文档切换到设计模式时，document暴露 execCommand 方法，该方法允许运行命令来操纵<mark>可编辑内容区域</mark>的元素。</p>
<p>再看可编辑内容区域（contenteditable）的定义</p>
<p>全局属性 contenteditable  是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。</p>
<p>也就是意味着除了 <mark><input>、<textarea></mark> 这样的输入域以外，是无法使用这个方法的</p>
<p>如果是需要获取input和textarea的值然后复制的，可以直接通过获取元素节点后通过select方法选中后直接调用document.execCommand('copy')即可</p>
<p>样例：</p>
<pre><code class="language-js">    const btn = document.querySelector('#btn');
    btn.addEventListener('click',() =&gt; {
        const input = document.createElement('input');
        input.setAttribute('readonly', 'readonly');
        input.setAttribute('value', 'hello world!');
        document.body.appendChild(input);
        input.select();
        if (document.execCommand('copy')) {
            document.execCommand('copy');
            console.log('复制成功');
        }
        document.body.removeChild(input);
    })
</code></pre>
<blockquote>
<p>如果需要隐藏新创建的元素时需要注意不能通过设置display值为none来实现，因为设置为none后将无法获取元素的属性值包括value，上一篇文章仔细探讨了display：none和visibility：hidden区别</p>
</blockquote>
<h4 id="createtextrange">createTextRange()</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range">MDN上对于range定义：</a></p>
<p>Range 接口表示一个包含节点与文本节点的一部分的文档片段。</p>
<p>可以用 Document 对象的 Document.createRange 方法创建 Range，也可以用 Selection 对象的 getRangeAt 方法获取 Range。另外，还可以通过 Document 对象的构造函数 Range() 来得到 Range</p>
<p>其原理与上种方法大同小异</p>
<p>样例：</p>
<pre><code class="language-js">        var div = document.getElementById('div1');
        if (document.body.createTextRange) {
            var range = document.body.createTextRange();
            range.moveToElementText(div);
            range.select();
        } else if (window.getSelection) {
            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(div);
            selection.removeAllRanges();
            selection.addRange(range);
        } else {
            console.warn(&quot;none&quot;);
        }
        document.execCommand(&quot;copy&quot;)
</code></pre>
<p><a href="https://www.cnblogs.com/dch0/p/12674129.html">参考一</a></p>
<p><a href="https://www.jb51.net/article/135605.htm">参考二</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[display none与visibility hidden的区别]]></title>
        <id>https://xiayun.im/post/display-visibility/</id>
        <link href="https://xiayun.im/post/display-visibility/">
        </link>
        <updated>2020-05-18T14:30:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>面试题常考，以为自己足够理解，但第一次在真实场景中使用还是<br>
没有注意，记录之，自省！</p>
</blockquote>
<h2 id="联系它们都能让元素不可见">联系：它们都能让元素不可见</h2>
<h2 id="区别">区别：</h2>
<h3 id="其一">其一</h3>
<ul>
<li>display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；</li>
<li>visibility: hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见</li>
</ul>
<h3 id="其二">其二</h3>
<ul>
<li>visibility:hidden; 使用该属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。</li>
<li>display:none; 使用该属性后，HTML元素（对象）的权度、高度等各种属性值都将“丢失”。</li>
</ul>
<h3 id="其三">其三</h3>
<ul>
<li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；</li>
<li>visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显示</li>
</ul>
<h3 id="其四">其四</h3>
<p>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</p>
<h3 id="其五">其五</h3>
<p>读屏器不会读取display: none;元素内容,会读取visibility: hidden;元素内容</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react中获取属性的问题]]></title>
        <id>https://xiayun.im/post/react-get-attribute/</id>
        <link href="https://xiayun.im/post/react-get-attribute/">
        </link>
        <updated>2020-05-13T14:12:40.000Z</updated>
        <content type="html"><![CDATA[<p>react 获取属性的问题，currentTarget确实是可以的，target确实是有问题的</p>
<p>父节点有属性data-cc 这时候点击父节点获取属性</p>
<p>正确方式是 event.currentTarget.getAttribute(“data-cc”)</p>
<p>而不是event.target.getAttribute(“data-cc”)</p>
<p>ps:</p>
<p>currentTarget 返回其事件监听器触发该事件的元素。 target 返回触发此事件的元素（事件的目标节点）。<br>
react添加自定义属性必须是 data-xx 形式<br>
最简单直白理解event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素</p>
<p>关于currentTarget和target详细区别见下篇文章</p>
<p><a href="https://blog.csdn.net/fortunegrant/article/details/83754945">原文地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[package.json和package-lock.json的区别]]></title>
        <id>https://xiayun.im/post/package.json-package.lock.json/</id>
        <link href="https://xiayun.im/post/package.json-package.lock.json/">
        </link>
        <updated>2020-05-11T14:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>package.json:</p>
<p>主要用来定义项目中需要依赖的包</p>
<p>package-lock.json：</p>
<p>根据官方文档，package-lock.json是生成的系统当前安装的库的具体来源和版本号，锁定版本。在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</p>
<p>当你执行npm install的时候， node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，node是从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。</p>
<p>当package.json与package-lock.json都不存在，执行&quot;npm install&quot;时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件，此时，你可以通过&quot;npm init --yes&quot;来生成package.json文件</p>
<p>参考：https://blog.csdn.net/u013992330/java/article/details/81110018</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css踩坑之z-index]]></title>
        <id>https://xiayun.im/post/css-z-index/</id>
        <link href="https://xiayun.im/post/css-z-index/">
        </link>
        <updated>2020-05-11T14:36:28.000Z</updated>
        <content type="html"><![CDATA[<p>z-index 属性指定一个元素的堆叠顺序<br>
拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面</p>
<p><mark>注意！！！： z-index 只适用于已定位的元素(position:absolute, position:relative, or position:fixed)</mark></p>
<p>所以z-index是一种依赖属性，依赖position属性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux和Flux]]></title>
        <id>https://xiayun.im/post/redux-and-flux/</id>
        <link href="https://xiayun.im/post/redux-and-flux/">
        </link>
        <updated>2020-05-11T14:35:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="flux">Flux</h2>
<h3 id="flux-优点">Flux 优点</h3>
<ul>
<li><strong>最重要的就是“<mark>单向数据流</mark>”的管理方式</strong>。在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</li>
</ul>
<p>解决的MVC的问题:</p>
<blockquote>
<p>MVC最大的问题就是无法禁绝View和Model之间的直接对话，对应于MVC中View就是Flux中的View，对应于MVC中的Model的就是Flux中的Store，在Flux中，Store只有get方法，没有set方法，根本可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action对象给Dispatcher</p>
</blockquote>
<h3 id="flux-不足">Flux 不足</h3>
<ol>
<li>Store之间依赖关系</li>
<li>难以进行服务器端渲染</li>
<li>Store混杂了逻辑和状态</li>
</ol>
<h2 id="redux">Redux</h2>
<p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p>
<p>Flux的基本原则是“单向数据流”,</p>
<p>Redux在此基础上强调三个基本原则：</p>
<ul>
<li>唯一数据源（Single Source of Truth）；</li>
</ul>
<p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。这个唯一Store上的状态，是一个树形的对象，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题</p>
<ul>
<li>保持状态只读（State is read-only）；</li>
</ul>
<p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p>
<ul>
<li>数据改变只能通过纯函数完成（Changes are made with pure functions）。</li>
</ul>
<p>这里所说的纯函数就是Reducer, Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。就以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer, reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次参数reducer，通过reducer函数完成规约所有元素的功能.</p>
<blockquote>
<p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的UI=render(state)思想完全契合</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redux理解]]></title>
        <id>https://xiayun.im/post/redux-learning/</id>
        <link href="https://xiayun.im/post/redux-learning/">
        </link>
        <updated>2020-05-10T03:57:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/05/09/YMT4Hg.jpg" alt="redux工作流程" loading="lazy"></figure>
<ol>
<li>一个比喻：</li>
</ol>
<ul>
<li>component --- 读者</li>
<li>store --- 图书馆</li>
<li>reducer --- 图书管理员</li>
<li>action --- 读者的动作</li>
</ul>
<ol start="2">
<li>流程理解</li>
</ol>
<ul>
<li>所有component的数据状态均来自统一的store中</li>
<li>如果需要更新store中的数据，需要在对应的事件中定义一个action，action就是一个对象，这个对象一般有两个属性，第一个是对action的描述，第二个是要改变的值</li>
<li>action会通过dispatch方法将type和value通过store的自动推送策略直接传递给reducer（虚线的作用）</li>
<li>reducer的两个参数</li>
</ul>
<blockquote>
<p>state：指的是原始仓库里的状态</p>
<p>action: 指的是action新传递的状态</p>
</blockquote>
<ul>
<li>reducer中不能直接修改state，需要深拷贝一个state对象，然后在新的state对象上操作，并最终返回新的state</li>
</ul>
<ol start="3">
<li>注意点</li>
</ol>
<ul>
<li>store必须是唯一的，多个store是坚决不允许，只能有一个store空间</li>
<li>只有store能改变自己的内容，Reducer不能改变</li>
<li>Reducer必须是纯函数</li>
</ul>
<p><strong>纯函数定义</strong></p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</p>
</blockquote>
<p>比如在Reducer里增加一个异步ajax函数，获取一些后端接口数据，然后再返回，这就是不允许的（包括你使用日期函数也是不允许的），因为违反了调用参数相同，返回相同的纯函数规则</p>
]]></content>
    </entry>
</feed>