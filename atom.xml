<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pxygogogo.github.io</id>
    <title>小潘的博客</title>
    <updated>2020-03-16T11:56:43.620Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pxygogogo.github.io"/>
    <link rel="self" href="https://pxygogogo.github.io/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://pxygogogo.github.io/images/avatar.png</logo>
    <icon>https://pxygogogo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[属性设置和屏蔽]]></title>
        <id>https://pxygogogo.github.io/post/js-properrty/</id>
        <link href="https://pxygogogo.github.io/post/js-properrty/">
        </link>
        <updated>2020-03-16T01:46:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="属性设置和屏蔽">属性设置和屏蔽</h2>
<ul>
<li>给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。</li>
<li>现在我们完整地讲解一下这个过程：</li>
</ul>
<pre><code>myObject.foo = &quot;bar&quot;;
</code></pre>
<ul>
<li>如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值。</li>
<li>如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作。如果原型链上找不到foo, foo就会被直接添加到myObject上。</li>
<li>然而，如果foo存在于原型链上层，赋值语句myObject.foo = &quot;bar&quot;的行为就会有些不同（而且可能很出人意料）。稍后我们会进行介绍。</li>
<li>如果属性名foo既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性。</li>
<li>屏蔽比我们想象中更加复杂。下面我们分析一下如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = &quot;bar&quot;会出现的三种情况。</li>
</ul>
<ol>
<li>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性（参见第3章）并且没有被标记为只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。</li>
<li>如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在[[Prototype]]链上层存在foo并且它是一个setter（参见第3章），那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。</li>
</ol>
<ul>
<li>大多数开发者都认为如果向[[Prototype]]链上层已经存在的属性（[[Put]]）赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的。如果你希望在第二种和第三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty(..)（参见第3章）来向myObject添加foo。</li>
</ul>
<blockquote>
<p>第二种情况可能是最令人意外的，只读属性会阻止[[Prototype]]链下层隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的foo看作是父类中的属性，它会被myObject继承（复制），这样一来myObject中的foo属性也是只读，所以无法创建。但是一定要注意，实际上并不会发生类似的继承复制（参见第4章和第5章）。这看起来有点奇怪，myObject对象竟然会因为其他对象中有一个只读foo就不能包含foo属性。更奇怪的是，这个限制只存在于=赋值中，使用Object. defineProperty(..)并不会受到影响。</p>
</blockquote>
<blockquote>
<p>来自你不知道的JavaScript上卷</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数柯里化]]></title>
        <id>https://pxygogogo.github.io/post/js-curry/</id>
        <link href="https://pxygogogo.github.io/post/js-curry/">
        </link>
        <updated>2020-03-14T13:01:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数柯里化">函数柯里化</h2>
<p><strong>柯里化（Currying）,维基百科上的解释是，把接受多个参数的函数转换成接受一个单一参数的函数</strong></p>
<p>先看一个简单的例子：</p>
<pre><code>    // 柯里化
    var foo = function(x) {
        return function(y) {
            return x + y
        }
    }
    
    foo(3)(4)       // 7
    
    // 普通方法
    var add = function(x, y) {
        return x + y;
    }
    
    add(3, 4)       //7

</code></pre>
<p>本来应该一次传入两个参数的add函数，柯里化方法，变成每次调用都只用传入一个参数，调用两次后，得到最后的结果。</p>
<p>再看看，一道经典的面试题。</p>
<pre><code>编写一个sum函数，实现如下功能：
console.log(sum(1)(2)(3)) // 6.
</code></pre>
<p>直接套用上面柯里化函数，多加一层return</p>
<pre><code>function sum(a) {
        return function(b) {
            return function(c) {
                return a + b + c;
            }
        }
    }
</code></pre>
<p>当然，柯里化不是为了解决面试题，它是应函数式编程而生，</p>
<h2 id="如何实现">如何实现</h2>
<p>还是看看上面的经典面试题。<br>
如果想实现 <mark>sum(1)(2)(3)(4)(5)...(n)</mark> 就得嵌套 <mark>n-1</mark>个匿名函数，</p>
<p>看起来并不优雅，如果我们预先知道有多少个参数要传入，可以利用递归方法解决</p>
<pre><code>function sum(a) {
        return function(b) {
             ...
            return function(n) {
                
            }
        }
    }
</code></pre>
<p>看起来并不优雅，如果我们预先知道有多少个参数要传入，可以利用递归方法解决</p>
<p>伪代码：</p>
<pre><code>var curry = function(fn) {
    return function() {
        // 假设柯里化的函数叫 curry_fn
        // if &quot;curry_fn接受到的参数数量等于fn接受参数的数量&quot;
        // return &quot;fn的执行结果&quot;
        // else return &quot;一个柯里化函数&quot;
    };
};
</code></pre>
<ul>
<li>递归出口：curry_fn接受到的参数数量等于fn接受参数的数量</li>
<li>重复逻辑：return &quot;一个柯里化函数&quot;</li>
</ul>
<pre><code>var add = function(num1, num2) {
        return num1 + num2;
    }
// 假设 sum 函数调用时，传入参数都是标准的数字
    function curry(add, n) {
       var count = 0, //接受的参数个数
           arr = []; // 存储递归过程的所有参数，用于递归出口计算值
           
       return function reply(arg) {
           arr.push(arg); // 收集递归参数
           
           if ( ++count &gt;= n) {
               //这里也可以在外面定义变量，保存每次计算后结果
               return arr.reduce(function(p, c) {
               // 返回函数执行结果
                   return p = add(p, c);
               }, 0) 
           } else {
           // 返回一个柯里化函数
               return reply;
           }
       }
    }
    var sum = curry(add, 4);
    
    sum(4)(3)(2)(1)  // 10    
    
</code></pre>
<p>根据上述的例子，可以得到，柯里化后的函数如果接受到全部参数则返回函数执行结果，否则返回一个柯里化函数。</p>
<p>这里还有一个小问题，如果调用次数多于约定数量，sum 就会报错，我们就可以设计成类似这样</p>
<pre><code>sum(1)(2)(3)(4)(); // 最后传入空参数，标识调用结束，
</code></pre>
<p>只需要简单修改下curry 函数</p>
<pre><code>function curry(add) {
       var arr = [];
       
       return function reply() {
         var arg = Array.prototype.slice.call(arguments);
         arr = arr.concat(arg);
         
          if (arg.length === 0) { // 递归结束条件，修改为 传入空参数
              return arr.reduce(function(p, c) {
                  return p = add(p, c);
              }, 0)
          } else {
              return reply;
          }
      }
    }
  
  console.log(sum(4)(3)(2)(1)(5)())   // 15
</code></pre>
<h2 id="简洁版实现">简洁版实现</h2>
<p>上面针对具体问题，引入柯里化方法解答，回到如何实现创建柯里化函数的通用方法。<br>
同样先看简单版本的方法，以add方法为例，代码来自《JavaScript高级程序设计》</p>
<pre><code>function curry(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    };
}

function add(num1, num2) {
    return num1 + num2;
}
var curriedAdd = curry(add, 5);

var curriedAdd2 = curry(add, 5, 12);

alert(curriedAdd(3))    // 8
alert(curriedAdd2())    // 17
</code></pre>
<h2 id="加强版实现">加强版实现</h2>
<p>上面add函数，可以换成任何其他函数，经过curry函数处理，都可以转成柯里化函数。<br>
这里在调用curry初始化时，就传入了一个参数，而且返回的函数 curriedAdd , curriedAdd2也没有被柯里化。要想实现更加通用的方法，在柯里化函数真正调用时，再传参数，</p>
<pre><code>function curry(fn) {
     ...
 }

function add(num1, num2) {
    return num1 + num2;
}

var curriedAdd = curry(add);

curriedAdd(3)(4) // 7
</code></pre>
<p>每次调用curry返回的函数，也被柯里化，可以继续传入一个或多个参数进行调用，</p>
<p>跟上面sum(1)(2)(3)(4) 非常类似,利用递归就可以实现。 关键是递归的出口，这里不能是传入一个空参数的调用， 而是原函数定义时，参数的总个数，柯里化函数调用时，满足了原函数的总个数，就返回计算结果，否则，继续返回柯里化函数。</p>
<p>原函数的入参总个数，可以利用length 属性获得</p>
<pre><code>function add(num1, num2) {
    return num1 + num2;
}

add.length // 
</code></pre>
<p>结合上面的代码，</p>
<pre><code>var curry = function(f) {
      var len = f.length;
      
        return function t() {
          var innerLength = arguments.length,
            args = Array.prototype.slice.call(arguments);
            
          if (innerLength &gt;= len) {   // 递归出口，f.length
             return f.apply(undefined, args)
          } else {
            return function() {
              var innerArgs = Array.prototype.slice.call(arguments),
                allArgs = args.concat(innerArgs);
                
              return t.apply(undefined, allArgs)
            }
          }
        }
    }
    
   // 测试一下
  function add(num1, num2) {
    return num1 + num2;
  }

   var curriedAdd = curry(add);
   add(2)(3);     //5

  // 一个参数
  function identity(value) {
     return value;
 }

   var curriedIdentify = curry(identify);
   curriedIdentify(4) // 4
</code></pre>
<p>到此，柯里化通用函数可以满足大部分需求了。</p>
<p><strong>在使用 apply 递归调用的时候，默认传入 undefined, 在其它场景下，可能需要传入 context， 绑定指定环境</strong></p>
<p>实际开发，推荐使用 <a href="https://lodash.com/docs/4.17.15#curry">lodash.curry</a> , 具体实现，可以参考下<a href="https://github.com/lodash/lodash/blob/4.3.0-npm-packages/lodash.curry/index.js">curry源码</a></p>
<h2 id="使用场景">使用场景</h2>
<p>讲了这么多curry函数的不同实现方法，那么实现了通用方法后，在那些场景下可以使用，或者说使用柯里化函数是否可以真实的提高代码质量，下面总结一下使用场景</p>
<ol>
<li>参数复用</li>
</ol>
<pre><code>// 正常正则验证字符串 reg.test(txt)

// 函数封装后
function check(reg, txt) {
    return reg.test(txt)
}

check(/\d+/g, 'test')       //false
check(/[a-z]+/g, 'test')    //true

// Currying后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}

var hasNumber = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasNumber('test1')      // true
hasNumber('testtest')   // false
hasLetter('21212')      // false
</code></pre>
<p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。</p>
<ol start="2">
<li>提前确认</li>
</ol>
<pre><code>var on = function(element, event, handler) {
    if (document.addEventListener) {
        if (element &amp;&amp; event &amp;&amp; handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element &amp;&amp; event &amp;&amp; handler) {
            element.attachEvent('on' + event, handler);
        }
    }
}

var on = (function() {
    if (document.addEventListener) {
        return function(element, event, handler) {
            if (element &amp;&amp; event &amp;&amp; handler) {
                element.addEventListener(event, handler, false);
            }
        };
    } else {
        return function(element, event, handler) {
            if (element &amp;&amp; event &amp;&amp; handler) {
                element.attachEvent('on' + event, handler);
            }
        };
    }
})();

//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了
var on = function(isSupport, element, event, handler) {
    isSupport = isSupport || document.addEventListener;
    if (isSupport) {
        return element.addEventListener(event, handler, false);
    } else {
        return element.attachEvent('on' + event, handler);
    }
}
</code></pre>
<p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。</p>
<ol start="3">
<li>延迟运行</li>
</ol>
<pre><code>Function.prototype.bind = function (context) {
    var _this = this
    var args = Array.prototype.slice.call(arguments, 1)
 
    return function() {
        return _this.apply(context, args)
    }
}
</code></pre>
<p>像我们js中经常使用的bind，实现的机制就是Currying.</p>
<ol start="4">
<li>函数式编程中，作为compose, functor, monad 等实现的基础</li>
</ol>
<p>有人说柯里化是应函数式编程而生，它在里面出现的概率就非常大了，在JS 函数式编程指南中，开篇就介绍了柯里化的重要性。</p>
<h2 id="柯里化的性能">柯里化的性能</h2>
<p>从上面实现部分的代码中，可以看到，使用柯里化函数，离不开闭包， arguments， 递归。</p>
<ul>
<li>闭包，函数中的变量都保存在内存中，内存消耗大，有可能导致内存泄漏。</li>
<li>递归，效率非常差，</li>
<li>arguments, 变量存取慢，访问性很差,存取arguments对象通常要比存取命名参数要慢一点</li>
<li>使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点</li>
</ul>
<h2 id="参考资料">参考资料：</h2>
<ul>
<li>https://www.jianshu.com/p/2975c25e4d71</li>
<li>https://segmentfault.com/a/1190000018265172</li>
<li>https://segmentfault.com/a/1190000018203637</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器中堆栈内存的底层处理]]></title>
        <id>https://pxygogogo.github.io/post/stack-heap-in-browser/</id>
        <link href="https://pxygogogo.github.io/post/stack-heap-in-browser/">
        </link>
        <updated>2020-03-13T05:31:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器执行代码需要经历什么">浏览器执行代码需要经历什么</h2>
<h3 id="编译">编译</h3>
<ul>
<li>词法解析：这个过程会将由字符组成的字符串分解成有意义的代码块（词法单元）</li>
<li>语法分析：这个过程将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法的树（抽象语法树 =&gt; <mark>AST</mark>）</li>
<li>代码生成：将<mark>AST</mark>转换为可执行代码的过程被称为代码生成</li>
</ul>
<h3 id="引擎编译执行代码">引擎编译执行代码</h3>
<p>然后将构建出的代码交给引擎（V8），这个时候可能会遇到<mark>变量提升、作用域和作用域链/闭包、变量对象、堆栈内存、GO/VO/AO/EC/ECStack</mark>...</p>
<blockquote>
<h4 id="几个术语说明">几个术语说明：</h4>
<p><mark>ECstack</mark>：执行上下文环境栈</p>
<p><mark>EC</mark>：执行上下文 分为全局执行上下文 <mark>EC(G)</mark> 和函数执行上下文(<mark>EC(...)</mark>)</p>
<p><mark>GO(Global Object)</mark>：全局对象浏览器端，会把GO赋值给window</p>
<p><mark>VO(Varible Object)</mark>：变量对象，存储当前上下文中的变量</p>
<p><mark>AO(Activation Object)</mark>：活动对象，在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色</p>
</blockquote>
<p>引擎在编译执行代码的过程中，首先会创建一个执行栈，也就是栈内存（ECStack =&gt; 执行环境栈），然后执行代码</p>
<p>在代码执行会创建EC(执行上下文)，执行上下文分为全局执行上下文（EC(G)）和函数执行上下文（EC(...)）,其中函数的执行上下文是私有的。</p>
<p>创建执行上下文的过程中，可能会创建：GO、VO、AO<br>
然后将进栈执行，创建好的上下文将压缩到栈中执行，执行后一些没用的上下文将出栈，有用的上下文会压缩到栈底（闭包）。栈底永远是全局执行上下文，栈顶则永远是当前执行上下文</p>
<h3 id="变量赋值的三步操作">变量赋值的三步操作</h3>
<ul>
<li>
<p>第一步，创建变量，这个过程叫做声明(declare)。</p>
</li>
<li>
<p>第二步，创建值。基本类型值会直接在栈中创建和存储；由于引用类型值是复杂的结构，所以需开辟一个存储对象中键值对（存储函数中代码）的内存空间，这个内存就是堆内存，所有的堆内存都有可被后续查找的16进制地址，后续关联赋值时，是把堆内存地址给予变量操作。</p>
</li>
<li>
<p>最后一步，将变量和值关联，这个过程叫做定义(defined)。这里，如果值只经过了声明，而没有进行赋值操作，这个值就是未定义(undefined)。</p>
</li>
</ul>
<blockquote>
<p>注：简单理解为</p>
<ul>
<li>栈内存存放执行代码和基本类型的值</li>
<li>堆内存存放复杂结构，如对象</li>
</ul>
</blockquote>
<p>例题：</p>
<pre><code>// 例一
let a = 12;
let b = a;
b = 13;
console.log(a);

// 例二
let a = {n:12};
let b = a;
b['n'] = 13;
console.log(a.n);

// 例三
let a = {n:12};
let b = a;
b = {n:13};
console.log(a.n);

</code></pre>
<p>例一<br>
<img src="https://s1.ax1x.com/2020/03/13/8nyz8A.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a值为12</p>
<p>例二<br>
<img src="https://s1.ax1x.com/2020/03/13/8n6AUg.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a.n为13</p>
<p>例三<br>
<img src="https://s1.ax1x.com/2020/03/13/8ncQSA.jpg" alt="image" loading="lazy"><br>
所以本问最终输出的a.n的值为12</p>
<h3 id="真实面试题">真实面试题</h3>
<ul>
<li>题一</li>
</ul>
<pre><code>let a = {
    n: 10
};
let b = a;
b.m = b = {
    n: 20
};
console.log(a);
console.log(b);

</code></pre>
<ul>
<li>解一<br>
<img src="https://s1.ax1x.com/2020/03/13/8n2zo8.jpg" alt="image" loading="lazy"></li>
</ul>
<p>所以最终输出的a为{n: 10, m: {n: 20}};b为{n: 20}</p>
<ul>
<li>题二</li>
</ul>
<pre><code>let x = [12, 23];
function fn(y) {
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y);
}
fn(x);
console.log(x);

</code></pre>
<ul>
<li>解二<br>
<img src="https://s1.ax1x.com/2020/03/13/8nvnzR.jpg" alt="image" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/03/13/8nv3dO.jpg" alt="image" loading="lazy"></figure>
<p>答案是：[100, 200] [100, 23]</p>
<h3 id="思考题">思考题</h3>
<ul>
<li>思考题一</li>
</ul>
<pre><code>var x = 10;
~ function (x) {
    console.log(x);
    x = x || 20 &amp;&amp; 30 || 40;
    console.log(x);
}();
console.log(x);
</code></pre>
<ul>
<li>思考题二</li>
</ul>
<pre><code>let x = [1, 2],
    y = [3, 4];
~ function (x) {
    x.push('A');
    x = x.slice(0);
    x.push('B');
    x = y;
    x.push('C');
    console.log(x, y);
}(x);
console.log(x, y);
</code></pre>
<ul>
<li>思考题一答案</li>
</ul>
<p><mark>undefined 30 10</mark></p>
<ul>
<li>思考题二答案</li>
</ul>
<p><mark>[3, 4, 'C'] [3, 4, 'C'] [1, 2, 'A'] [3, 4, 'C']</mark></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mongoose得到的对象不能增加属性解决方法（两种）]]></title>
        <id>https://pxygogogo.github.io/post/mongoose-query/</id>
        <link href="https://pxygogogo.github.io/post/mongoose-query/">
        </link>
        <updated>2020-03-11T04:39:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实例">实例</h2>
<ul>
<li>Notice模型文件如下：</li>
</ul>
<pre><code>const mongoose = require('mongoose');

const schema = mongoose.Schema({
    userId:{type:String},
    time: {type:String},
    medicines: {type:Array},
    noticePerson:{type:String},
    acrtTime:{type:String},
});

module.exports = mongoose.model('Notice',schema);
</code></pre>
<ul>
<li>路由响应如下：</li>
</ul>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            result.email = email; //无法生效
            res.send(result);
        }
    });
</code></pre>
<ul>
<li>问题描述：<br>
希望向得到的result数据中添加一个email属性，但直接添加无法成功</li>
</ul>
<hr>
<h2 id="原因">原因</h2>
<ul>
<li>因为Mongoose是個ODM (Object Document Mapper)，类似于操作关系型数据库使用的ORM(Object Relational Mapper)，我们使用Mongoose取到的数据的结构是要依赖于我们定义的schema结构的。增加的email属性在schema中没有定义，所以我们在取到的结果中增加email属性是无效的</li>
</ul>
<hr>
<h2 id="解决办法">解决办法</h2>
<ul>
<li>解决办法一</li>
</ul>
<p><mark>在schema中直接增加需要补充的属性</mark></p>
<p>在本例中即向Notice模型中添加一个email字段</p>
<ul>
<li>解决办法二</li>
</ul>
<p><mark>把查询到的结果clone一个对象，然后在新对象中补充属性</mark></p>
<pre><code>router.post('/notices', async (req, res) =&gt; {
            const {email} = await User.findById(req.id, {email: 1});
            const result = await Notice.create(req.body);
            const data = {
                ...result._doc,
                email,
            };
            res.send(data);
        }
    });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssh 免密码快速登录（MacOs）]]></title>
        <id>https://pxygogogo.github.io/post/ssh-login/</id>
        <link href="https://pxygogogo.github.io/post/ssh-login/">
        </link>
        <updated>2020-03-05T11:47:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建秘钥文件">1.创建秘钥文件</h2>
<ul>
<li>打开终端，执行 ssh-keygen 命令创建密钥对：</li>
</ul>
<blockquote>
<pre><code class="language-bash">ssh-keygen -t rsa -C 'your email@domain.com'
-t 指定密钥类型，默认即 rsa ，可以省略
-C 设置注释文字，比如你的邮箱，可以省略
</code></pre>
</blockquote>
<ul>
<li>生成过程中会提示输入密码两次，如果不想在使用公钥的时候输入密码，可以回车跳过；<br>
密钥默认保存位置在 <code>~/.ssh</code> 目录下，打开后会看到私钥文件 <code>id_rsa</code> 和公钥文件 <code>id_rsa.pub</code>；</li>
</ul>
<h2 id="2复制公钥至服务器">2.复制公钥至服务器</h2>
<ul>
<li>
<p>通过宝塔面板直接将<code>~/.ssh/id_rsa.pub</code>配置到服务器的<code>~/.ssh/authorized_keys</code>文件中</p>
</li>
<li>
<p>使用 scp 命令将本地的公钥文件 <code>id_rsa.pub</code> 复制到需要连接的Linux服务器：</p>
<pre><code class="language-bash">scp ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-bash">scp -P &lt;端口号&gt; ~/.ssh/id_rsa.pub &lt;用户名&gt;@&lt;ip地址&gt;:/home/id_rsa.pub
</code></pre>
</li>
<li>
<p>把公钥追加到服务器ssh认证文件中:</p>
<pre><code class="language-bash">cat /home/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
</li>
<li>
<p>这时候在本地终端中使用用户名和ip登录就不需要密码了：</p>
<pre><code class="language-xml">ssh &lt;用户名&gt;@&lt;ip&gt;
</code></pre>
</li>
<li>
<p>如果修改了ssh默认连接端口的话，需要加上端口信息：</p>
<pre><code class="language-xml">ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;ip地址&gt;
</code></pre>
</li>
</ul>
<h2 id="3配置快捷登录">3.配置快捷登录</h2>
<ul>
<li>在本地 <code>~/.ssh/config</code> 配置文件中添加ssh服务器信息（可多个），格式：</li>
</ul>
<blockquote>
<pre><code class="language-ruby">Host            alias            #自定义别名
HostName        hostname         #替换为你的ssh服务器ip或domain
Port            port             #ssh服务器端口，默认为22
User            user             #ssh服务器用户名
IdentityFile    ~/.ssh/id_rsa    #第一个步骤生成的公钥文件对应的私钥文件
</code></pre>
</blockquote>
<ul>
<li>配置成功后，即可直接通过<code>ssh alias</code>登录</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序页面跳转的一系列注意点]]></title>
        <id>https://pxygogogo.github.io/post/nagivation-problems/</id>
        <link href="https://pxygogogo.github.io/post/nagivation-problems/">
        </link>
        <updated>2020-02-13T11:34:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>showModel 回调无法跳转除TabBar之外的页面</p>
<ul>
<li>回调中只能使用switchTab进行跳转</li>
</ul>
</li>
<li>
<p>switchTab跳转后页面不刷新</p>
<ul>
<li>
<p>法一：switchTab成功跳转后调用success,此时可以拿到跳转后页面的page对象,从而调用页面onLoad方法重载页面</p>
<pre><code class="language-javascript">wx.switchTab({
    url: '/pages/index/index',
    success: function(e) {
        let page = getCurrentPages().pop();
        if (page == undefined || page == null) return;
        page.onLoad();
    }
})
</code></pre>
</li>
<li>
<p>法二：当switchTab点击过的时候，只有第一次加载数据，第二次点击的时候是不刷新数据的，这个时候只要在需要每次点击都需要刷新数据的TabBar页的js里加上onShow的方法即可</p>
<pre><code class="language-javascript"> onShow:function(e){
       this.onLoad();
 },
</code></pre>
</li>
</ul>
</li>
<li>
<p>TabBar页面只能使用switchTab跳转</p>
<ul>
<li>文档里有写，使用时需注意</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js for in 和 for of 区别及遍历相关注意点]]></title>
        <id>https://pxygogogo.github.io/post/js-iterator/</id>
        <link href="https://pxygogogo.github.io/post/js-iterator/">
        </link>
        <updated>2020-01-02T03:02:41.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>例一</li>
</ul>
<pre><code>const obj = {
        a: 1,
        b: 2,
        c: 3
    }
    for (let i in obj) {
        console.log(i)
        // a
        // b
        // c
    }
    for (let i of obj) {
        console.log(i)
        // Uncaught TypeError: obj is not iterable 报错了
    }
</code></pre>
<p>以上代码通过 for in 和 for of 对一个obj对象进行遍历,for in 正常的获取了对象的 key值,分别打印 a、b、c,而 for of却报错了。</p>
<ul>
<li>例二</li>
</ul>
<p>以上是遍历对象,下面再看一个遍历数组的例子。</p>
<pre><code>const arr = ['a', 'b', 'c']
    // for in 循环
    for (let i in arr) {
        console.log(i)
        // 0
        // 1
        // 2
    }
    
    // for of
    for (let i of arr) {
        console.log(i)
        // a
        // b
        // c
    }
</code></pre>
<p>以上代码是对一个数组进行遍历, for in 返回的值为 0、1、2,返回的是数组的下标，而 for of 返回的是 a、b、c,返回的是数组的值</p>
<p>结合上面两个例子，分析得出</p>
<h2 id="for-in-特点">for in 特点</h2>
<ul>
<li>
<p>for ... in 循环返回的值都是数据结构的 键值名。<br>
遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。</p>
</li>
<li>
<p>for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——例3</p>
</li>
<li>
<p>特别情况下, for ... in 循环会以任意的顺序遍历键名</p>
</li>
</ul>
<blockquote>
<p>注：使用for in 遍历对象是无法直接获取属性值得，因为他实际上遍历的是对象中的可枚举属性，你需要手动获取属性值</p>
<p>遍历数组下标时采用的是数组顺序（for循环或者其他迭代器），但是遍历对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样。因此在不同的环境中需要保证一致性时，不用相信任何观察到的顺序，它们是不可靠的</p>
<p>（引用自你不知道的JavaScript上卷）</p>
</blockquote>
<h2 id="for-of-特点">for of 特点</h2>
<ul>
<li>
<p>for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名</p>
</li>
<li>
<p>一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。</p>
</li>
<li>
<p>例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterable</p>
</li>
<li>
<p>for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。</p>
</li>
<li>
<p>提供了遍历所有数据结构的统一接口</p>
</li>
</ul>
<blockquote>
<p>for of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来手动遍历数组，看看它是怎么工作的</p>
</blockquote>
<pre><code>var arr = [1,2,3];
var it = arr[Symbpl.iterator]();

it.next(); // {value:1,done:false}
it.next(); // {value:2,done:false}
it.next(); // {value:3,done:false}
it.next(); // {done:true}
</code></pre>
<h2 id="哪些数据结构部署了-symboliteratoer属性了呢">哪些数据结构部署了 Symbol.iteratoer属性了呢?</h2>
<p>只要有 iterator 接口的数据结构,都可以使用 for of循环。</p>
<ul>
<li>数组 Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>arguments对象</li>
<li>Nodelist对象, 就是获取的dom列表集合<br>
以上这些都可以直接使用 for of 循环。 凡是部署了 iterator 接口的数据结构也都可以使用数组的 扩展运算符(...)、和解构赋值等操作。</li>
</ul>
<p>我也想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of</p>
<p>以例1为例</p>
<pre><code> const obj = {
        a: 1,
        b: 2,
        c: 3
    }

    for (let i of Object.keys(obj)) {
        console.log(i)
        // 1
        // 2
        // 3
    }
</code></pre>
<p>也可以给一个对象部署 Symbol.iterator属性。</p>
<ul>
<li>当你为对象添加myObject.toString()方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加myObjectSymbol.iterator方法，就可以遍历这个对象了。</li>
</ul>
<p>举个例子，假设你正在使用jQuery，尽管你非常钟情于里面的.each()方法，但你还是想让jQuery对象也支持for-of循环，你可以这样做：</p>
<pre><code>jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
</code></pre>
<p>所有拥有Symbol.iterator的对象被称为可迭代的。在接下来的文章中你会发现，可迭代对象的概念几乎贯穿于整门语言之中，不仅是for-of循环，还有Map和Set构造函数、解构赋值，以及新的展开操作符。</p>
<ul>
<li>for...of的步骤<br>
for-of循环首先调用集合的Symbol.iterator方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next()方法的对象；for-of循环将重复调用这个方法，每次循环调用一次。</li>
</ul>
<blockquote>
<p>和组数不同，普通的对象没有内置的@@iterator，所以无法自动完成for of遍历。之所以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型<br>
当然，你可以给任何想遍历的对象定义@@iterator，举例来说：</p>
</blockquote>
<pre><code>var myObject = {
        a: { x: 2 },
        b: 3
    };
    Object.defineProperty(myObject, Symbol.iterator, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: function () {
            var o = this;
            var idx = 0;
            var ks = Object.keys(o);
            return {
                next: function () {
                    return {
                        value: o[ks[idx++]],
                        done: (idx &gt; ks.length)
                    };
                }
            };
        }
    });

    // 手动遍历myObject
    var it = myObject[Symbol.iterator]();
    console.log(it.next()); //{value:2,done:false}  
    console.log(it.next()); //{value:e,done:false}
    console.log(it.next()); //{value:undefined,done:true}

    //用 for of 遍历myObject
    for (var v of myObject) {
        console.log(v);
    }
    // 2
    // 3
</code></pre>
<p>参考文章：</p>
<blockquote>
<p>链接：<br>
你不知道的JavaScript上卷3.4节<br>
https://www.jianshu.com/p/c43f418d6bf0<br>
https://www.cnblogs.com/owenzh/p/11058708.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js实现深浅拷贝]]></title>
        <id>https://pxygogogo.github.io/post/js-copy/</id>
        <link href="https://pxygogogo.github.io/post/js-copy/">
        </link>
        <updated>2020-01-01T13:01:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实现浅拷贝">实现浅拷贝</h2>
<ul>
<li>一、...实现</li>
</ul>
<pre><code>let copy = {...{a:1}};
</code></pre>
<ul>
<li>二、(ES6)Object.assign实现</li>
</ul>
<pre><code>let copy = Object.assign({},{a:1});
</code></pre>
<h2 id="实现深拷贝">实现深拷贝</h2>
<ul>
<li>一、JSON.stringify()/JSON.parse()实现</li>
</ul>
<pre><code>let obj = {a: 1, b: {x: 3}};
let deepCopy = JSON.parse(JSON.stringify(obj));
</code></pre>
<p><mark>注：这种方法实施的前提必须是实施的对象是JSON安全的</mark></p>
<ul>
<li>二、递归拷贝</li>
</ul>
<pre><code>function deepClone(obj) {
    let copy = obj.instanceof Arrary ? [] : {};
    for (let i in obj) {
        if(obj.hasOwnProperty(i)) {
            copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
        }
    }
    return copy
}

</code></pre>
]]></content>
    </entry>
</feed>