<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiayun.im</id>
    <title>小潘的博客</title>
    <updated>2020-05-01T14:34:57.786Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiayun.im"/>
    <link rel="self" href="https://xiayun.im/atom.xml"/>
    <subtitle>平凡的世界</subtitle>
    <logo>https://xiayun.im/images/avatar.png</logo>
    <icon>https://xiayun.im/favicon.ico</icon>
    <rights>All rights reserved 2020, 小潘的博客</rights>
    <entry>
        <title type="html"><![CDATA[ThinkPHP5+宝塔+nginx环境下访问路由出现404问题]]></title>
        <id>https://xiayun.im/post/tp5-nigix-404/</id>
        <link href="https://xiayun.im/post/tp5-nigix-404/">
        </link>
        <updated>2020-05-01T14:20:28.000Z</updated>
        <content type="html"><![CDATA[<p>在网站伪静态下添加</p>
<pre><code>location / {
    if (!-e $request_filename){
	      rewrite ^(.*)$ /index.php?s=$1 last; break;
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker创建mysql数据库并导入sql文件]]></title>
        <id>https://xiayun.im/post/docker-mysql/</id>
        <link href="https://xiayun.im/post/docker-mysql/">
        </link>
        <updated>2020-04-23T14:08:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1安装mysql">1.安装mysql</h2>
<h3 id="11-拉取镜像以5726为例">1.1 拉取镜像（以5.7.26为例）</h3>
<pre><code>docker pull mysql:5.7.26
</code></pre>
<h3 id="12-运行容器">1.2 运行容器</h3>
<pre><code>docker run -itd --name mysql-test -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre>
<p>参数说明：</p>
<ul>
<li>-p 3307:3306 ：映射容器服务的 3307 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3307 访问到 MySQL 的服务。</li>
<li>MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。</li>
</ul>
<h2 id="2docker操作mysql创建数据库">2.docker操作mysql创建数据库</h2>
<h3 id="21-确定linux中的docker容器mysql正常运行">2.1 确定linux中的docker容器（mysql）正常运行</h3>
<h3 id="22-执行命令docker-exec-it-容器名称-bash-进入容器bash-即进入到mysql容器中">2.2 执行命令：“docker exec -it 容器名称 bash” 进入容器bash-即进入到mysql容器中</h3>
<h3 id="23-登录mysqlmysql-uroot-p-使用root账号登录mysql">2.3 登录mysql：mysql -uroot -p      使用root账号登录mysql</h3>
<h3 id="24-页面提示输入密码数据root-账号所属密码登录到mysql中">2.4 页面提示输入密码——数据root 账号所属密码，登录到mysql中</h3>
<h3 id="25-create-database-数据库名称-命令创建新数据库">2.5 create database 数据库名称  命令创建新数据库；</h3>
<blockquote>
<p>注：所有的mysql命名末尾一定要加“;”<br>
mysql基本命令：</p>
<p>-h数据库主机<br>
-u用户<br>
-p密码<br>
-P端口号（大写P）</p>
<p>例如：mysql -h127.0.0.1 -uroot -p123456 -P3306<br>
PS:-p密码部分，可以直接指定密码，如果不指定，会提示输入密码。</p>
</blockquote>
<h2 id="3将准备好的sql文件导入到docker中的mysql中">3.将准备好的sql文件导入到docker中的mysql中</h2>
<h3 id="31-备份sql文件存储目录">3.1 备份sql文件存储目录</h3>
<pre><code>/data
</code></pre>
<h3 id="32-查看当前mysql容器名称">3.2 查看当前mysql容器名称</h3>
<pre><code>docker ps
</code></pre>
<h3 id="33-将sql导入mysql">3.3 将sql导入mysql</h3>
<pre><code>docker exec -i mysql5.7 mysql -uroot -p123456 mydb &lt; /data/mydb.sql
</code></pre>
<blockquote>
<p>注：</p>
<p>mydb 为：数据库名</p>
<p>mysql5.7 为：容器名</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MAMP Pro更改文件上传大小限制]]></title>
        <id>https://xiayun.im/post/mamp-pro-settings/</id>
        <link href="https://xiayun.im/post/mamp-pro-settings/">
        </link>
        <updated>2020-04-20T12:10:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>近期由于项目需求，需要上传一些几百MB的文件，但是大文件始终报500错误，连TP5的提示都没给，遂Google一通终得一优解，特此记录。</p>
</blockquote>
<p>主要思路：</p>
<ul>
<li>修改php.ini文件（需为当前项目使用的php版本）</li>
</ul>
<p><mark>（MAMP Pro菜单栏选择File-&gt;Edit Template-&gt;PHP-&gt;选择对应版本即可）</mark></p>
<pre><code>file_uploads = On           ; 是否允许上传文件 On/Off 默认是On
upload_max_filesize = 32M   ; 上传文件的最大限制（改为需求大小即可）
post_max_size = 32M         ; 通过Post提交的最多数据（改为需求大小即可）
</code></pre>
<ul>
<li>考虑网络传输快慢,可以修改一些参数</li>
</ul>
<pre><code>max_execution_time = 30000  ; 脚本最长的执行时间 单位为秒
max_input_time = 600        ; 接收提交的数据的时间限制 单位为秒
memory_limit = 1024M        ; 最大的内存消耗
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css常见单位]]></title>
        <id>https://xiayun.im/post/css-unit/</id>
        <link href="https://xiayun.im/post/css-unit/">
        </link>
        <updated>2020-04-16T03:27:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常见单位">常见单位</h2>
<ol>
<li>px：像素相对长度单位，相对于显示器屏幕分辨率</li>
<li>em：相对长度单位基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li>
<li>rem：相对单位可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</li>
<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li>
<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li>
<li>vmin：vw和vh中较小的那个。</li>
<li>vmax：vw和vh中较大的那个。</li>
<li>%:百分比</li>
<li>in:寸</li>
<li>cm:厘米</li>
<li>mm:毫米</li>
<li>pt:point，大约1/72寸</li>
<li>pc:pica，大约6pt，1/6寸</li>
<li>ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀)</li>
<li>ch:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)</li>
</ol>
<h2 id="常用">常用</h2>
<p>其中用的最多的单位是<strong>px、em、rem</strong>，这三个的区别是：<br>
px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</p>
<p>em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</p>
<p>对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。</p>
<p>rem中的r意思是root（根源），这也就不难理解了。</p>
<p><mark>em/rem</mark>：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。</p>
<p>关于vh/vw与%区别：<br>
vh和vw大小是相对于视口的高度和宽度，而不是父元素的，%单位是相对于包含它的最近的父元素的高度和宽度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[zsh: no matches found不能指定版本]]></title>
        <id>https://xiayun.im/post/tp-composer/</id>
        <link href="https://xiayun.im/post/tp-composer/">
        </link>
        <updated>2020-04-16T02:55:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<pre><code>composer create-project topthink/think=5.0.* tp50 --prefer-dist
</code></pre>
<p>使用composer安装Thinkphp5.0时发生错误</p>
<pre><code># 提示
zsh: no matches found: think=5.0.*
</code></pre>
<h2 id="解决">解决</h2>
<pre><code># 编辑
nano ~/.zshrc
# 添加
setopt no_nomatch 
# 生效
source ~/.zshrc
</code></pre>
<p>再安装即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回流与重绘]]></title>
        <id>https://xiayun.im/post/reflow-repaint/</id>
        <link href="https://xiayun.im/post/reflow-repaint/">
        </link>
        <updated>2020-04-12T10:24:09.000Z</updated>
        <content type="html"><![CDATA[<p><mark>一句话：回流必将引起重绘，重绘不一定会引起回流。</mark></p>
<p>想要真正的了解回流和重绘，我们首先需要搞清楚浏览器的渲染过程。</p>
<h2 id="浏览器的渲染过程">浏览器的渲染过程</h2>
<p>浏览器渲染过程如下：</p>
<ol>
<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层,在这里先不做展开）</li>
</ol>
<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>
<h3 id="生成渲染树">生成渲染树</h3>
<p>为了构建渲染树，浏览器主要完成了以下工作：</p>
<ol>
<li>从DOM树的根节点开始遍历每个可见节点。</li>
<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>
<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>
</ol>
<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>
<ul>
<li>一些不会渲染输出的节点，比如script、meta、link等。</li>
<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>
</ul>
<p><strong>注意：渲染树只包含可见的节点</strong></p>
<h3 id="回流">回流</h3>
<p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p>会导致回流的操作：</p>
<ol>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
<li>元素尺寸或位置发生改变（包括外边距、内边距、边框大小、高度和宽度等）</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ol>
<p>一些常用且会导致回流的属性和方法：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()</li>
</ul>
<h3 id="重绘">重绘</h3>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<mark>color、background-color、visibility</mark>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<h2 id="性能影响">性能影响</h2>
<p>回流比重绘的代价要更高。</p>
<p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p>
<p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br>
当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p>
<h2 id="如何避免">如何避免</h2>
<h3 id="css">CSS</h3>
<ol>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。</li>
</ol>
<h3 id="javascript">JavaScript</h3>
<ol>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ol>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://juejin.im/post/5c0f104551882509a7683d63#heading-7">你真的了解回流和重绘吗</a></p>
<p><a href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何正确给用户密码加密（转载）]]></title>
        <id>https://xiayun.im/post/encrypt/</id>
        <link href="https://xiayun.im/post/encrypt/">
        </link>
        <updated>2020-04-10T14:03:08.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.infoq.cn/article/how-to-encrypt-the-user-password-correctly">原文</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https详解]]></title>
        <id>https://xiayun.im/post/https/</id>
        <link href="https://xiayun.im/post/https/">
        </link>
        <updated>2020-04-08T13:58:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是https">什么是HTTPS</h2>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</p>
<p>HTTPS 其实是一个“非常简单”的协议，RFC 文档很小，只有短短的 7 页，<mark>里面规定了新的协议名“https”，默认端口号 443</mark>，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。也就是说，除了协议名“http”和端口号 80 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。</p>
<h2 id="为什么要有https">为什么要有HTTPS</h2>
<p>简单的回答是“因为 HTTP <mark>不安全</mark>”。由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。</p>
<h2 id="怎么样才算安全">怎么样才算安全</h2>
<p>既然 HTTP“不安全”，那什么样的通信过程才是安全的呢？通常认为，<mark>如果通信过程具备了四个特性，就可以认为是“安全”的，</mark> 这四个特性是：<mark>机密性、完整性，身份认证和不可否认</mark>。</p>
<p><strong>机密性</strong>（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。</p>
<p><strong>完整性</strong>（Integrity，也叫一致性）是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。</p>
<p>机密性虽然可以让数据成为“秘密”，但不能防止黑客对数据的修改，黑客可以替换数据，调整数据的顺序，或者增加、删除部分数据，破坏通信过程。</p>
<p><strong>身份认证</strong>（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。</p>
<p>如果通信时另一方是假冒的网站，那么数据再保密也没有用，黑客完全可以使用冒充的身份“套”出各种信息，加密和没加密一样。</p>
<p>第四个特性是<strong>不可否认</strong>（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。</p>
<p>使用前三个特性，可以解决安全通信的大部分问题，但如果缺了不可否认，那通信的事务真实性就得不到保证，有可能出现“老赖”。</p>
<p>所以，只有同时具备了机密性、完整性、身份认证、不可否认这四个特性，通信双方的利益才能有保障，才能算得上是真正的安全。</p>
<h2 id="http-与-https-的区别">HTTP 与 HTTPS 的区别</h2>
<ol>
<li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li>
<li>HTTP 的端口号是 80，HTTPS 是 443</li>
<li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</li>
<li>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
</ol>
<h2 id="https的实现">HTTPS的实现</h2>
<h3 id="实现机密性"><strong>实现机密性</strong></h3>
<p>实现机密性最常用的手段是“<mark>加密</mark>”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。这里的“钥匙”就叫做“<mark>密钥</mark>”（key），加密前的消息叫“<mark>明文</mark>”（plain text/clear text），加密后的乱码叫“<mark>密文</mark>”（cipher text），使用密钥还原明文的过程叫“<mark>解密</mark>”（decrypt），是加密的反操作，加密解密的操作过程就是“<mark>加密算法</mark>”。</p>
<p>按照密钥的使用方式，加密可以分为两大类：<mark>对称加密和非对称加密</mark>。</p>
<h4 id="对称加密">对称加密</h4>
<p>“对称加密”很好理解，就是指加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<p>举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密钥，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。<br>
<img src="https://static001.geekbang.org/resource/image/8f/49/8feab67c25a534f8c72077680927ab49.png" alt="image" loading="lazy"></p>
<p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p>
<p>AES 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法。</p>
<p>ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错的算法。</p>
<p><mark>加密分组模式对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。</mark></p>
<h4 id="非对称加密">非对称加密</h4>
<p>对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“密钥交换”。</p>
<p>因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</p>
<p>这个问题该怎么解决呢？</p>
<p>答案是<mark>非对称加密</mark></p>
<p>它有两个密钥，一个叫“<mark>公钥</mark>”（public key），一个叫“<mark>私钥</mark>”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</p>
<p>公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</p>
<p>非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/89/17/89344c2e493600b486d5349a84318417.png" alt="image" loading="lazy"></figure>
<p>非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。</p>
<p>RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在 1024 已经不安全，普遍认为至少要 2048 位。</p>
<h4 id="混合加密">混合加密</h4>
<p>看到这里，你是不是认为可以抛弃对称加密，只用非对称加密来实现机密性呢？</p>
<p>很遗憾，虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</p>
<p>现在 TLS 里使用的<mark>混合加密</mark>方式，其实说穿了也很简单：</p>
<p>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</p>
<p>然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</p>
<p>对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/e4/85/e41f87110aeea3e548d58cc35a478e85.png" alt="image" loading="lazy"></figure>
<p>这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。</p>
<h3 id="实现完整性-身份认证-不可否认"><strong>实现完整性、身份认证、不可否认</strong></h3>
<p>仅有机密性，离安全还差的很远。</p>
<p>黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</p>
<p>另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</p>
<p>所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。</p>
<h4 id="摘要算法">摘要算法</h4>
<p>实现完整性的手段主要是<strong>摘要算法</strong>（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。</p>
<p>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</p>
<p>换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</p>
<p>摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。</p>
<p>因为摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数（PRF，pseudo random function）。</p>
<p>你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。</p>
<p>目前 TLS 推荐使用的是 SHA-1 的后继者：<strong>SHA-2</strong>。</p>
<p><strong>SHA-2</strong> 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。</p>
<h4 id="完整性">完整性</h4>
<p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性</p>
<p>如果黑客在中间哪怕改动了一个标点符号，摘要也会完全不同，网站计算比对就会发现消息被窜改，是不可信的。</p>
<p>不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</p>
<p>所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。</p>
<p>这有个术语，叫哈希消息认证码（HMAC）。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/c2/96/c2e10e9afa1393281b5633b1648f2696.png" alt="image" loading="lazy"></figure>
<h4 id="数字签名">数字签名</h4>
<p>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。<mark>但这里还有漏洞，就是通信的两个端点</mark>（endpoint）。</p>
<p>就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</p>
<p>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</p>
<p><mark>在TLS中非对称加密里的“私钥”，使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。</mark></p>
<p>数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。</p>
<p>但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。</p>
<p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/84/d2/84a79826588ca35bf6ddcade027597d2.png" alt="image" loading="lazy"></figure>
<p>刚才的这两个行为也有专用术语，叫做“<mark>签名</mark>”和“<mark>验签</mark>”。</p>
<p>只要你和网站互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份</p>
<h4 id="数字证书和-ca">数字证书和 CA</h4>
<p>到现在，综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，是不是已经完美了呢？</p>
<p>不是的，这里还有一个“<mark>公钥的信任</mark>”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段</p>
<p>但这次实在是“没招”了，要终结这个“死循环”，就必须引入“外力”，找一个公认的可信第三方，让它作为“信任的起点，递归的终点”，构建起公钥的信任链。</p>
<p>这个“第三方”就是我们常说的 <mark>CA</mark>（Certificate Authority，证书认证机构）。<mark>它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度</mark>，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p>
<p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“<mark>数字证书</mark>”（Certificate）</p>
<p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。</p>
<p>DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。</p>
<p>不过，CA 怎么证明自己呢？</p>
<p>这还是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 <mark>Root CA</mark>，就只能自己证明自己了，这个就叫“<mark>自签名证书</mark>”（Self-Signed Certificate）或者“<mark>根证书</mark>”（Root Certificate）。</p>
<p>你必须相信，否则整个证书信任链就走不下去了。</p>
<figure data-type="image" tabindex="5"><img src="https://static001.geekbang.org/resource/image/8f/9c/8f0813e9555ba1a40bd2170734aced9c.png" alt="image" loading="lazy"></figure>
<p>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</p>
<h4 id="证书体系的弱点">证书体系的弱点</h4>
<p>证书体系（PKI，Public Key Infrastructure）虽然是目前整个网络世界的安全基础设施，但绝对的安全是不存在的，它也有弱点，还是关键的“信任”二字。</p>
<p>如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。</p>
<p>这两种事情并不是“耸人听闻”，都曾经实际出现过。所以，需要再给证书体系打上一些补丁。</p>
<p>针对第一种，开发出了 <mark>CRL（证书吊销列表，Certificate revocation list）和 OCSP（在线证书状态协议，Online Certificate Status Protocol），及时废止有问题的证书</mark>。</p>
<p>对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上“下狠手”了，撤销对 CA 的信任，<mark>列入“黑名单”，这样它颁发的所有证书就都会被认为是不安全的</mark>。</p>
<h2 id="小结">小结</h2>
<blockquote>
<ol>
<li>加密算法的核心思想是“把一个小秘密（密钥）转化为一个大秘密（密文消息）”，守住了小秘密，也就守住了大秘密；</li>
<li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；</li>
<li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；</li>
<li>把对称加密和非对称加密结合起来就得到了“又好又快”的混合加密，也就是 TLS 里使用的加密方式。</li>
<li>摘要算法用来实现完整性，能够为数据生成独一无二的“指纹”，常用的算法是 SHA-2；</li>
<li>数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认；</li>
<li>公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的；</li>
<li>作为信任链的源头 CA 有时也会不可信，解决办法有 CRL、OCSP，还有终止信任。</li>
</ol>
</blockquote>
<p>参考：极客时间透视HTTP协议-罗剑锋</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http演变史]]></title>
        <id>https://xiayun.im/post/http-history/</id>
        <link href="https://xiayun.im/post/http-history/">
        </link>
        <updated>2020-04-07T12:46:02.000Z</updated>
        <content type="html"><![CDATA[<p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<h2 id="一-http09">一、HTTP/0.9</h2>
<ul>
<li>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</li>
<li>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</li>
</ul>
<pre><code>样例
GET /index.html
</code></pre>
<h2 id="二-http10">二、HTTP/1.0</h2>
<p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>
<p>改进之处：</p>
<ol>
<li>增加了 HEAD、POST等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ol>
<p>主要问题：</p>
<blockquote>
<p>无法复用TCP连接</p>
</blockquote>
<pre><code>样例
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
</code></pre>
<h2 id="三-http11">三、HTTP/1.1</h2>
<p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了今天，直到现在还是最流行的版本。</p>
<p>改进之处：</p>
<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ol>
<p>主要问题：</p>
<blockquote>
<p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为&quot;队头堵塞&quot;（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<p>臃肿的消息首部</p>
</blockquote>
<h2 id="四-http2">四、HTTP/2</h2>
<p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>
<p>Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，并在 Chrome 里应用于自家的服务器，如同十多年前的网景与微软一样，从实际的用户方来“倒逼”HTTP 协议的变革，这也开启了第二次的“浏览器大战”。</p>
<p>历史再次重演，不过这次的胜利者是 Google，Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</p>
<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道，多路复用，支持优先级和流量控制</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>流量控制算法优化</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ol>
<h2 id="五-http3">五、HTTP/3</h2>
<p>在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。</p>
<p>“功夫不负有心人”，当然也是因为 QUIC 确实自身素质过硬。</p>
<p>在前年，也就是 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[typeof 和 instance]]></title>
        <id>https://xiayun.im/post/js-typeof-instance/</id>
        <link href="https://xiayun.im/post/js-typeof-instance/">
        </link>
        <updated>2020-03-28T06:40:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="typeof">typeof</h2>
<h3 id="typeof-对于基本类型除了-null都可以显示正确的类型">typeof 对于基本类型，除了 null都可以显示正确的类型</h3>
<pre><code class="language-js">typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof b // b 没有声明，但是还会显示 undefined
</code></pre>
<h3 id="typeof-对于对象除了函数都会显示-object">typeof 对于对象，除了函数都会显示 object</h3>
<pre><code class="language-js">typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
</code></pre>
<p>对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug</p>
<pre><code class="language-js">typeof null // 'object'
</code></pre>
<h2 id="instanceof">instanceof</h2>
<h3 id="instanceof-可以正确的判断对象的类型因为内部机制是通过判断对象的原型链中是不是能找到类型的-prototype">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</h3>
<pre><code class="language-js">试着实现一下 instanceof
function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}
</code></pre>
]]></content>
    </entry>
</feed>