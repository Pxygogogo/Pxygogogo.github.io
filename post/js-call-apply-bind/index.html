<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>js中call、apply、bind理解 | 小潘的博客</title>
<link rel="shortcut icon" href="https://xiayun.im/favicon.ico?v=1592493435314">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiayun.im/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="js中call、apply、bind理解 | 小潘的博客 - Atom Feed" href="https://xiayun.im/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个函数的存在意义是什么？答案是改变函数执行时的上下文，再具体一点就是改变函数运行时的this指向
一、方法定义
call()

语法

fun..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiayun.im">
  <img class="avatar" src="https://xiayun.im/images/avatar.png?v=1592493435314" alt="">
  </a>
  <h1 class="site-title">
    小潘的博客
  </h1>
  <p class="site-description">
    平凡的世界
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Pxygogogo" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              js中call、apply、bind理解
            </h2>
            <div class="post-info">
              <span>
                2019-12-22
              </span>
              <span>
                4 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个函数的存在意义是什么？答案是<strong>改变函数执行时的上下文，再具体一点就是改变函数运行时的this指向</strong></p>
<h2 id="一-方法定义">一、方法定义</h2>
<h3 id="call">call()</h3>
<ul>
<li>语法</li>
</ul>
<pre><code>fun.call(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
<ul>
<li>参数</li>
</ul>
<p><strong>thisArg：fun函数运行时指定的this值，可能的值为：</strong></p>
<blockquote>
<ul>
<li>不传，或者传null，undefined，this指向Window/Global对象</li>
<li>传递另一个函数的函数名fun2，this指向函数fun2的引用</li>
<li>值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean</li>
<li>传递一个对象，函数中的this指向这个对象</li>
</ul>
</blockquote>
<p><strong>arg1, arg2, ...</strong></p>
<p>指定的参数列表。</p>
<h3 id="apply">apply()</h3>
<ul>
<li>语法：</li>
</ul>
<pre><code>fun.apply([thisArg[,argArray]])
</code></pre>
<ul>
<li>参数</li>
</ul>
<p><strong>thisArg</strong></p>
<p>同上call 的thisArg参数。</p>
<p><strong>argArray</strong></p>
<p>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</p>
<p>语法与 call() 方法的语法几乎完全相同，唯一的区别在于，apply的第二个参数必须是一个包含多个参数的数组（或类数组对象）。apply的这个特性很重要，<br>
在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<h3 id="bind">bind()</h3>
<p>bind() 函数会创建一个新函数（称为绑定函数）</p>
<blockquote>
<ul>
<li>bind是ES5新增的一个方法</li>
<li>传参和call或apply类似</li>
<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>
<li>返回对函数的引用</li>
</ul>
</blockquote>
<ul>
<li>语法</li>
</ul>
<pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
<ul>
<li>参数</li>
</ul>
<p><strong>thisArg</strong></p>
<p>bind的thisArg参数也和call方法一样，thisArg如果未传，那么 Global/Window对象被用作 thisObj。</p>
<p><strong>arg1 … argN</strong></p>
<p>可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效</p>
<h2 id="二-call-apply-bind的区别">二、call、apply、bind的区别</h2>
<ul>
<li>call的arg传参需一个一个传，apply则直接传一个数组</li>
</ul>
<pre><code>function hello(name,age){
 console.log(name);
  console.log(age);
  }
hello.call(this,&quot;tsrot&quot;,24);
hello.apply(this,[&quot;tsrot&quot;,24]);
</code></pre>
<ul>
<li>call和apply直接执行函数，而bind需要再一次调用</li>
</ul>
<pre><code>var obj = {
    x: 81,
    };
var foo = {
    getX: function() {
        return this.x;
    }
    }
console.log(foo.getX.bind(obj)());  
console.log(foo.getX.call(obj));    
console.log(foo.getX.apply(obj));
</code></pre>
<h2 id="三-运用场景">三、运用场景</h2>
<ol>
<li>实现继承</li>
</ol>
<pre><code>function Animal(name) {
    this.name = name;
    this.showName=function () {
        console.log(this.name)
    }
}

function Cat(name) {
    Animal.call(this,name);
}
var cat = new Cat('Black Cat');
cat.showName();


</code></pre>
<ol start="2">
<li>数组追加</li>
</ol>
<pre><code>let arr1=[1,2,3];
let arr2= [4,5,6];
Array.prototype.push.apply(arr1,arr2); //或者[].push.apply(arr1, arr2);
console.log(arr1)
</code></pre>
<ol start="3">
<li>获取数组中的最大值和最小值</li>
</ol>
<pre><code>let num = [1,3,5,7,2,-10,11];
let maxNum = Math.max.apply(Math, num);
let minNum = Math.min.apply(Math, num);
console.log(maxNum); 
console.log(minNum);

</code></pre>
<ol start="4">
<li>将伪数组转化为数组</li>
</ol>
<pre><code>let fakeArr = {0:'a',1:'b',length:2};
let arr1 = Array.prototype.slice.call(fakeArr);
console.log(arr1[0]);
let arr2 = [].slice.call(fakeArr);
console.log(arr2[0]);
arr1.push(&quot;c&quot;);
console.log(arr1);
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89">一、方法定义</a>
<ul>
<li><a href="#call">call()</a></li>
<li><a href="#apply">apply()</a></li>
<li><a href="#bind">bind()</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-call-apply-bind%E7%9A%84%E5%8C%BA%E5%88%AB">二、call、apply、bind的区别</a></li>
<li><a href="#%E4%B8%89-%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF">三、运用场景</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiayun.im/post/js-this/">
              <h3 class="post-title">
                this绑定
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiayun.im/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
